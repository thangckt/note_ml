

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>09. PyTorch Model Deployment</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.5ea377869091fd0449014c60fc090103.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebook/pytorch_deep_learning/09_pytorch_model_deployment';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="PyTorch Extra Resources" href="extras/pytorch_extra_resources.html" />
    <link rel="prev" title="08. PyTorch Paper Replicating" href="08_pytorch_paper_replicating.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../README.html">
  
  
  
  
  
  
    <p class="title logo__title"></p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Basic of ML &amp; DL</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../0_basic_MLDL/1_0_ml_overview.html">Machine Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../0_basic_MLDL/1_1_ml_supervised_unsuppersives.html">Supervised vs. Unsuppervised</a></li>
<li class="toctree-l2"><a class="reference internal" href="../0_basic_MLDL/1_2_regression.html">Regression &amp; Model Assessment</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../0_basic_MLDL/2_0_dl_overview.html">Deep Learning Overview</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../0_basic_MLDL/2_1_dl_neural_network.html">What is a neural network?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../0_basic_MLDL/2_2_layers.html">Standard Layers</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../0_basic_MLDL/3_1_workflow.html">Workflow in ML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_basic_MLDL/3_2_Model_template.html">Core Ml templates</a></li>


</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">PyTorch for Deep Learning</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="00_overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="00_pytorch_fundamentals.html">00. PyTorch Fundamentals</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_pytorch_workflow.html">01. PyTorch Workflow Fundamentals</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_pytorch_classification.html">02. PyTorch Neural Network Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_pytorch_computer_vision.html">03. PyTorch Computer Vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_pytorch_custom_datasets.html">04. PyTorch Custom Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_pytorch_going_modular.html">05. PyTorch Going Modular</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_pytorch_transfer_learning.html">06. PyTorch Transfer Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_pytorch_experiment_tracking.html">07. PyTorch Experiment Tracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_pytorch_paper_replicating.html">08. PyTorch Paper Replicating</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">09. PyTorch Model Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="extras/pytorch_extra_resources.html">PyTorch Extra Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="extras/pytorch_cheatsheet.html">PyTorch Cheatsheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="extras/pytorch_most_common_errors.html">The Three Most Common Errors in PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="extras/pytorch_setup.html">Setup to code PyTorch</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Zero to Mastery Machine Learning</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../zero_to_mastery_ml/README.html">Zero to Mastery Machine Learning</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Practices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../1_Practices/1_PT_Linear_Regression.html">Linear Regression</a></li>





<li class="toctree-l1"><a class="reference internal" href="../1_Practices/2_PT_Logistic_Regression.html">Logistic Regression</a></li>





</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/thangckt/note_ml/edit/main/notebook/pytorch_deep_learning/09_pytorch_model_deployment.ipynb" target="_blank"
   class="btn btn-sm btn-source-edit-button"
   title="Suggest edit"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>

</a>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>09. PyTorch Model Deployment</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-machine-learning-model-deployment">What is machine learning model deployment?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-deploy-a-machine-learning-model">Why deploy a machine learning model?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#different-types-of-machine-learning-model-deployment">Different types of machine learning model deployment</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wheres-it-going-to-go">Where’s it going to go?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hows-it-going-to-function">How’s it going to function?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ways-to-deploy-a-machine-learning-model">Ways to deploy a machine learning model</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#what-were-going-to-cover">What we’re going to cover</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#where-can-you-get-help">Where can you get help?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-setup">0. Getting setup</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-data">1. Getting data</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#foodvision-mini-model-deployment-experiment-outline">2. FoodVision Mini model deployment experiment outline</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-an-effnetb2-feature-extractor">3. Creating an EffNetB2 feature extractor</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-function-to-make-an-effnetb2-feature-extractor">3.1 Creating a function to make an EffNetB2 feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-dataloaders-for-effnetb2">3.2 Creating DataLoaders for EffNetB2</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#training-effnetb2-feature-extractor">3.3 Training EffNetB2 feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inspecting-effnetb2-loss-curves">3.4 Inspecting EffNetB2 loss curves</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-effnetb2-feature-extractor">3.5 Saving EffNetB2 feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#checking-the-size-of-effnetb2-feature-extractor">3.6 Checking the size of EffNetB2 feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#collecting-effnetb2-feature-extractor-stats">3.7 Collecting EffNetB2 feature extractor stats</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-vit-feature-extractor">4. Creating a ViT feature extractor</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-dataloaders-for-vit">4.1 Create DataLoaders for ViT</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#training-vit-feature-extractor">4.2 Training ViT feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inspecting-vit-loss-curves">4.3 Inspecting ViT loss curves</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-vit-feature-extractor">4.4 Saving ViT feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#checking-the-size-of-vit-feature-extractor">4.5 Checking the size of ViT feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#collecting-vit-feature-extractor-stats">4.6 Collecting ViT feature extractor stats</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#making-predictions-with-our-trained-models-and-timing-them">5. Making predictions with our trained models and timing them</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-function-to-make-predictions-across-the-test-dataset">5.1 Creating a function to make predictions across the test dataset</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-and-timing-predictions-with-effnetb2">5.2 Making and timing predictions with EffNetB2</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-and-timing-predictions-with-vit">5.3 Making and timing predictions with ViT</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#comparing-model-results-prediction-times-and-size">6. Comparing model results, prediction times and size</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualizing-the-speed-vs-performance-tradeoff">6.1 Visualizing the speed vs. performance tradeoff</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bringing-foodvision-mini-to-life-by-creating-a-gradio-demo">7. Bringing FoodVision Mini to life by creating a Gradio demo</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gradio-overview">7.1 Gradio overview</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-function-to-map-our-inputs-and-outputs">7.2 Creating a function to map our inputs and outputs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-list-of-example-images">7.3 Creating a list of example images</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#building-a-gradio-interface">7.4 Building a Gradio interface</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-mini-gradio-demo-into-a-deployable-app">8. Turning our FoodVision Mini Gradio Demo into a deployable app</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-hugging-face-spaces">8.1 What is Hugging Face Spaces?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deployed-gradio-app-structure">8.2 Deployed Gradio app structure</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-demos-folder-to-store-our-foodvision-mini-app-files">8.3 Creating a <code class="docutils literal notranslate"><span class="pre">demos</span></code> folder to store our FoodVision Mini app files</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-folder-of-example-images-to-use-with-our-foodvision-mini-demo">8.4 Creating a folder of example images to use with our FoodVision Mini demo</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#moving-our-trained-effnetb2-model-to-our-foodvision-mini-demo-directory">8.5 Moving our trained EffNetB2 model to our FoodVision Mini demo directory</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-effnetb2-model-into-a-python-script-model-py">8.6 Turning our EffNetB2 model into a Python script (<code class="docutils literal notranslate"><span class="pre">model.py</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-mini-gradio-app-into-a-python-script-app-py">8.7 Turning our FoodVision Mini Gradio app into a Python script (<code class="docutils literal notranslate"><span class="pre">app.py</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-requirements-file-for-foodvision-mini-requirements-txt">8.8 Creating a requirements file for FoodVision Mini (<code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deploying-our-foodvision-mini-app-to-huggingface-spaces">9. Deploying our FoodVision Mini app to HuggingFace Spaces</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downloading-our-foodvision-mini-app-files">9.1 Downloading our FoodVision Mini app files</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#running-our-foodvision-mini-demo-locally">9.2 Running our FoodVision Mini demo locally</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#uploading-to-hugging-face">9.3 Uploading to Hugging Face</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-foodvision-big">10. Creating FoodVision Big</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-model-and-transforms-for-foodvision-big">10.1 Creating a model and transforms for FoodVision Big</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-data-for-foodvision-big">10.2 Getting data for FoodVision Big</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-subset-of-the-food101-dataset-for-faster-experimenting">10.3 Creating a subset of the Food101 dataset for faster experimenting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-food101-datasets-into-dataloaders">10.4 Turning our Food101 datasets into <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>s</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#training-foodvision-big-model">10.5 Training FoodVision Big model</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inspecting-loss-curves-of-foodvision-big-model">10.6 Inspecting loss curves of FoodVision Big model</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-and-loading-foodvision-big">10.7 Saving and loading FoodVision Big</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#checking-foodvision-big-model-size">10.8 Checking FoodVision Big model size</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-big-model-into-a-deployable-app">11. Turning our FoodVision Big model into a deployable app</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downloading-an-example-image-and-moving-it-to-the-examples-directory">11.1 Downloading an example image and moving it to the <code class="docutils literal notranslate"><span class="pre">examples</span></code> directory</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-food101-class-names-to-file-class-names-txt">11.2 Saving Food101 class names to file (<code class="docutils literal notranslate"><span class="pre">class_names.txt</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-big-model-into-a-python-script-model-py">11.3 Turning our FoodVision Big model into a Python script (<code class="docutils literal notranslate"><span class="pre">model.py</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-big-gradio-app-into-a-python-script-app-py">11.4 Turning our FoodVision Big Gradio app into a Python script (<code class="docutils literal notranslate"><span class="pre">app.py</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-requirements-file-for-foodvision-big-requirements-txt">11.5 Creating a requirements file for FoodVision Big (<code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downloading-our-foodvision-big-app-files">11.6 Downloading our FoodVision Big app files</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deploying-our-foodvision-big-app-to-huggingface-spaces">11.7 Deploying our FoodVision Big app to HuggingFace Spaces</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#main-takeaways">Main takeaways</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#extra-curriculum">Extra-curriculum</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <p><a href="https://colab.research.google.com/github/thangckt/pytorch-deep-learning/blob/main/09_pytorch_model_deployment.ipynb" target="_parent"><img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p>
<p><a class="reference external" href="https://thangckt.github.io/pytorch_deep_learning/slides/09_pytorch_model_deployment.pdf">View Slides</a></p>
<section class="tex2jax_ignore mathjax_ignore" id="pytorch-model-deployment">
<h1>09. PyTorch Model Deployment<a class="headerlink" href="#pytorch-model-deployment" title="Permalink to this heading">#</a></h1>
<p>Welcome to Milestone Project 3: PyTorch Model Deployment!</p>
<p>We’ve come a long way with our FoodVision Mini project.</p>
<p>But so far our PyTorch models have only been accessible to us.</p>
<p>How about we bring FoodVision Mini to life and make it publically accessible?</p>
<p>In other words, <strong>we’re going to deploy our FoodVision Mini model to the internet as a usable app!</strong></p>
<img alt="demo of foodvision mini computer vision model being used on a mobile device to predict on an image of sushi and getting it right" src="https://github.com/thangckt/pytorch-deep-learning/raw/main/images/09-model-deployment-what-were-doing-demo-trimmed-cropped-small.gif" />
<p><em>Trying out the <a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_mini">deployed version of FoodVision Mini</a> (what we’re going to build) on my lunch. The model got it right too 🍣!</em></p>
<section id="what-is-machine-learning-model-deployment">
<h2>What is machine learning model deployment?<a class="headerlink" href="#what-is-machine-learning-model-deployment" title="Permalink to this heading">#</a></h2>
<p><strong>Machine learning model deployment</strong> is the process of making your machine learning model accessible to someone or something else.</p>
<p>Someone else being a person who can interact with your model in some way.</p>
<p>For example, someone taking a photo on their smartphone of food and then having our FoodVision Mini model classify it into pizza, steak or sushi.</p>
<p>Something else might be another program, app or even another model that interacts with your machine learning model(s).</p>
<p>For example, a banking database might rely on a machine learning model making predictions as to whether a transaction is fraudulent or not before transferring funds.</p>
<p>Or an operating system may lower its resource consumption based on a machine learning model making predictions on how much power someone generally uses at specific times of day.</p>
<p>These use cases can be mixed and matched as well.</p>
<p>For example, a Tesla car’s computer vision system will interact with the car’s route planning program (something else) and then the route planning program will get inputs and feedback from the driver (someone else).</p>
<img alt="two use cases for model deployment, making your model available to someone else, for example, someone using it in an app, or making it available to something else such as another program or model" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-what-is-model-deployment-someone-or-something-else.png" />
<p><em>Machine learning model deployment involves making your model available to someone or something else. For example, someone might use your model as part of a food recognition app (such as FoodVision Mini or <a class="reference external" href="https://nutrify.app">Nutrify</a>). And something else might be another model or program using your model such as a banking system using a machine learning model to detect if a transaction is fraud or not.</em></p>
</section>
<section id="why-deploy-a-machine-learning-model">
<h2>Why deploy a machine learning model?<a class="headerlink" href="#why-deploy-a-machine-learning-model" title="Permalink to this heading">#</a></h2>
<p>One of the most important philosophical questions in machine learning is:</p>
<div align="center">
<img src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-does-it-exist.jpeg" alt="curious dinosaur often referred to as philosoraptor asking the question if a machine learning model never leaves a notebook, does it exist?" style="width:300px"/>
</div>
<p>Deploying a model is as important as training one.</p>
<p>Because although you can get a pretty good idea of how your model’s going to function by evaluting it on a well crafted test set or visualizing its results, you never really know how it’s going to perform until you release it to the wild.</p>
<p>Having people who’ve never used your model interact with it will often reveal edge cases you never thought of during training.</p>
<p>For example, what happens if someone was to upload a photo that <em>wasn’t</em> of food to our FoodVision Mini model?</p>
<p>One solution would be to create another model that first classifies images as “food” or “not food” and passing the target image through that model first (this is what <a class="reference external" href="https://nutrify.app">Nutrify</a> does).</p>
<p>Then if the image is of “food” it goes to our FoodVision Mini model and gets classified into pizza, steak or sushi.</p>
<p>And if it’s “not food”, a message is displayed.</p>
<p>But what if these predictions were wrong?</p>
<p>What happens then?</p>
<p>You can see how these questions could keep going.</p>
<p>Thus this highlights the importance of model deployment: it helps you figure out errors in your model that aren’t obvious during training/testing.</p>
<img alt="A PyTorch workflow with added model deployment and monitoring step" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-pytorch-workflow-with-deployment.png" />
<p><em>We covered a PyTorch workflow back in <a class="reference external" href="https://www.learnpytorch.io/01_pytorch_workflow/">01. PyTorch Workflow</a>. But once you’ve got a good model, deployment is a good next step. Monitoring involves seeing how your model goes on the most important data split: data from the real world. For more resources on deployment and monitoring see <a class="reference external" href="https://www.learnpytorch.io/pytorch_extra_resources/#resources-for-machine-learning-and-deep-learning-engineering">PyTorch Extra Resources</a>.</em></p>
</section>
<section id="different-types-of-machine-learning-model-deployment">
<h2>Different types of machine learning model deployment<a class="headerlink" href="#different-types-of-machine-learning-model-deployment" title="Permalink to this heading">#</a></h2>
<p>Whole books could be written on the different types of machine learning model deployment (and many good ones are listed in <a class="reference external" href="https://www.learnpytorch.io/pytorch_extra_resources/#resources-for-machine-learning-and-deep-learning-engineering">PyTorch Extra Resources</a>).</p>
<p>And the field is still developing in terms of best practices.</p>
<p>But I like to start with the question:</p>
<blockquote>
<div><p>“What is the most ideal scenario for my machine learning model to be used?”</p>
</div></blockquote>
<p>And then work backwards from there.</p>
<p>Of course, you may not know this ahead of time. But you’re smart enough to imagine such things.</p>
<p>In the case of FoodVision Mini, our ideal scenario might be:</p>
<ul class="simple">
<li><p>Someone takes a photo on a mobile device (through an app or web broswer).</p></li>
<li><p>The prediction comes back fast.</p></li>
</ul>
<p>Easy.</p>
<p>So we’ve got two main criteria:</p>
<ol class="arabic simple">
<li><p>The model should work on a mobile device (this means there will be some compute constraints).</p></li>
<li><p>The model should make predictions <em>fast</em> (because a slow app is a boring app).</p></li>
</ol>
<p>And of course, depending on your use case, your requirements may vary.</p>
<p>You may notice the above two points break down into another two questions:</p>
<ol class="arabic simple">
<li><p><strong>Where’s it going to go?</strong> - As in, where is it going to be stored?</p></li>
<li><p><strong>How’s it going to function?</strong> - As in, does it return predictions immediately? Or do they come later?</p></li>
</ol>
<img alt="some questions to ask when starting to deploy machine learning models, what's the model ideal use case, then work backwards and ask where's my model going to go and how's my model going to function" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-deployment-questions-to-ask.png" />
<p><em>When starting to deploy machine learning models, it’s helpful to start by asking what’s the most ideal use case and then work backwards from there, asking where the model’s going to go and then how it’s going to function.</em></p>
<section id="wheres-it-going-to-go">
<h3>Where’s it going to go?<a class="headerlink" href="#wheres-it-going-to-go" title="Permalink to this heading">#</a></h3>
<p>When you deploy your machine learning model, where does it live?</p>
<p>The main debate here is usually on-device (also called edge/in the browser) or on the cloud (a computer/server that isn’t the <em>actual</em> device someone/something calls the model from).</p>
<p>Both have their pros and cons.</p>
<div class="pst-scrollable-table-container"><table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Deployment location</strong></p></th>
<th class="head"><p><strong>Pros</strong></p></th>
<th class="head"><p><strong>Cons</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>On-device (edge/in the browser)</strong></p></td>
<td><p>Can be very fast (since no data leaves the device)</p></td>
<td><p>Limited compute power (larger models take longer to run)</p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><p>Privacy preserving (again no data has to leave the device)</p></td>
<td><p>Limited storage space (smaller model size required)</p></td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><p>No internet connection required (sometimes)</p></td>
<td><p>Device-specific skills often required</p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><p></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><strong>On cloud</strong></p></td>
<td><p>Near unlimited compute power (can scale up when needed)</p></td>
<td><p>Costs can get out of hand (if proper scaling limits aren’t enforced)</p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><p>Can deploy one model and use everywhere (via API)</p></td>
<td><p>Predictions can be slower due to data having to leave device and predictions having to come back (network latency)</p></td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><p>Links into existing cloud ecosystem</p></td>
<td><p>Data has to leave device (this may cause privacy concerns)</p></td>
</tr>
</tbody>
</table>
</div>
<p>There are more details to these but I’ve left resources in the <a class="reference external" href="https://www.learnpytorch.io/09_pytorch_model_deployment/#extra-curriculum">extra-curriculum</a> to learn more.</p>
<p>Let’s give an example.</p>
<p>If we’re deploying FoodVision Mini as an app, we want it to perform well and fast.</p>
<p>So which model would we prefer?</p>
<ol class="arabic simple">
<li><p>A model on-device that performs at 95% accuracy with an inference time (latency) of one second per prediction.</p></li>
<li><p>A model on the cloud that performs at 98% accuracy with an inference time of 10 seconds per per prediction (bigger, better model but takes longer to compute).</p></li>
</ol>
<p>I’ve made these numbers up but they showcase a potential difference between on-device and on the cloud.</p>
<p>Option 1 could potentially be a smaller less performant model that runs fast because its able to fit on a mobile device.</p>
<p>Option 2 could potentially a larger more performant model that requires more compute and storage but it takes a bit longer to run because we have to send data off the device and get it back (so even though the actual prediction might be fast, the network time and data transfer has to factored in).</p>
<p>For FoodVision Mini, we’d likely prefer option 1, because the small hit in performance is far outweighed by the faster inference speed.</p>
<img alt="tesla computer vision system on device vs on the cloud" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-model-deployment-on-device-vs-cloud.png" />
<p><em>In the case of a Tesla car’s computer vision system, which would be better? A smaller model that performs well on device (model is on the car) or a larger model that performs better that’s on the cloud? In this case, you’d much prefer the model being on the car. The extra network time it would take for data to go from the car to the cloud and then back to the car just wouldn’t be worth it (or potentially even possible with poor signal areas).</em></p>
<blockquote>
<div><p><strong>Note:</strong> For a full example of seeing what it’s like to deploy a PyTorch model to an edge device, see the <a class="reference external" href="https://pytorch.org/tutorials/intermediate/realtime_rpi.html">PyTorch tutorial on achieving real-time inference (30fps+)</a> with a computer vision model on a Raspberry Pi.</p>
</div></blockquote>
</section>
<section id="hows-it-going-to-function">
<h3>How’s it going to function?<a class="headerlink" href="#hows-it-going-to-function" title="Permalink to this heading">#</a></h3>
<p>Back to the ideal use case, when you deploy your machine learning model, how should it work?</p>
<p>As in, would you like predictions returned immediately?</p>
<p>Or is it okay for them to happen later?</p>
<p>These two scenarios are generally referred to as:</p>
<ul class="simple">
<li><p><strong>Online (real-time)</strong> - Predicitions/inference happen <strong>immediately</strong>. For example, someone uploads an image, the image gets transformed and predictions are returned or someone makes a purchase and the transaction is verified to be non-fradulent by a model so the purchase can go through.</p></li>
<li><p><strong>Offline (batch)</strong> - Predictions/inference happen <strong>periodically</strong>. For example, a photos application sorts your images into different categories (such as beach, mealtime, family, friends) whilst your mobile device is plugged into charge.</p></li>
</ul>
<blockquote>
<div><p><strong>Note:</strong> “Batch” refers to inference being performed on multiple samples at a time. However, to add a little confusion, batch processing can happen immediately/online (multiple images being classified at once) and/or offline (mutliple images being predicted/trained on at once).</p>
</div></blockquote>
<p>The main difference between each being: predictions being made immediately or periodically.</p>
<p>Periodically can have a varying timescale too, from every few seconds to every few hours or days.</p>
<p>And you can mix and match the two.</p>
<p>In the case of FoodVision Mini, we’d want our inference pipeline to happen online (real-time), so when someone uploads an image of pizza, steak or sushi, the prediction results are returned immediately (any slower than real-time would make a boring experience).</p>
<p>But for our training pipeline, it’s okay for it to happen in a batch (offline) fashion, which is what we’ve been doing throughout the previous chapters.</p>
</section>
<section id="ways-to-deploy-a-machine-learning-model">
<h3>Ways to deploy a machine learning model<a class="headerlink" href="#ways-to-deploy-a-machine-learning-model" title="Permalink to this heading">#</a></h3>
<p>We’ve discussed a couple of options for deploying machine learning models (on-device and cloud).</p>
<p>And each of these will have their specific requirements:</p>
<div class="pst-scrollable-table-container"><table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Tool/resource</strong></p></th>
<th class="head"><p><strong>Deployment type</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://developers.google.com/ml-kit">Google’s ML Kit</a></p></td>
<td><p>On-device (Android and iOS)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://developer.apple.com/documentation/coreml">Apple’s Core ML</a> and <a class="reference external" href="https://coremltools.readme.io/docs"><code class="docutils literal notranslate"><span class="pre">coremltools</span></code> Python package</a></p></td>
<td><p>On-device (all Apple devices)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://aws.amazon.com/sagemaker/">Amazon Web Service’s (AWS) Sagemaker</a></p></td>
<td><p>Cloud</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://cloud.google.com/vertex-ai">Google Cloud’s Vertex AI</a></p></td>
<td><p>Cloud</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://azure.microsoft.com/en-au/services/machine-learning/">Microsoft’s Azure Machine Learning</a></p></td>
<td><p>Cloud</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://huggingface.co/spaces">Hugging Face Spaces</a></p></td>
<td><p>Cloud</p></td>
</tr>
<tr class="row-even"><td><p>API with <a class="reference external" href="https://fastapi.tiangolo.com">FastAPI</a></p></td>
<td><p>Cloud/self-hosted server</p></td>
</tr>
<tr class="row-odd"><td><p>API with <a class="reference external" href="https://pytorch.org/serve/">TorchServe</a></p></td>
<td><p>Cloud/self-hosted server</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://onnx.ai/index.html">ONNX (Open Neural Network Exchange)</a></p></td>
<td><p>Many/general</p></td>
</tr>
<tr class="row-odd"><td><p>Many more…</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p><strong>Note:</strong> An <a class="reference external" href="https://en.wikipedia.org/wiki/API">application programming interface (API)</a> is a way for two (or more) computer programs to interact with each other. For example, if your model was deployed as API, you would be able to write a program that could send data to it and then receive predictions back.</p>
</div></blockquote>
<p>Which option you choose will be highly dependent on what you’re building/who you’re working with.</p>
<p>But with so many options, it can be very intimidating.</p>
<p>So best to start small and keep it simple.</p>
<p>And one of the best ways to do so is by turning your machine learning model into a demo app with <a class="reference external" href="https://gradio.app">Gradio</a> and then deploying it on Hugging Face Spaces.</p>
<p>We’ll be doing just that with FoodVision Mini later on.</p>
<img alt="tools and places to deploy machine learning models" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-tools-and-places-to-deploy-ml-models.png" />
<p><em>A handful of places and tools to host and deploy machine learning models. There are plenty I’ve missed so if you’d like to add more, please leave a <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/discussions">discussion on GitHub</a>.</em></p>
</section>
</section>
<section id="what-were-going-to-cover">
<h2>What we’re going to cover<a class="headerlink" href="#what-were-going-to-cover" title="Permalink to this heading">#</a></h2>
<p>Enough talking about deploying a machine learning model.</p>
<p>Let’s become machine learning engineers and actually deploy one.</p>
<p>Our goal is to deploy our FoodVision Model via a demo Gradio app with the following metrics:</p>
<ol class="arabic simple">
<li><p><strong>Performance:</strong> 95%+ accuracy.</p></li>
<li><p><strong>Speed:</strong> real-time inference of 30FPS+ (each prediction has a latency of lower than ~0.03s).</p></li>
</ol>
<p>We’ll start by running an experiment to compare our best two models so far: EffNetB2 and ViT feature extractors.</p>
<p>Then we’ll deploy the one which performs closest to our goal metrics.</p>
<p>Finally, we’ll finish with a (BIG) surprise bonus.</p>
<div class="pst-scrollable-table-container"><table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Topic</strong></p></th>
<th class="head"><p><strong>Contents</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>0. Getting setup</strong></p></td>
<td><p>We’ve written a fair bit of useful code over the past few sections, let’s download it and make sure we can use it again.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>1. Get data</strong></p></td>
<td><p>Let’s download the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/data/pizza_steak_sushi_20_percent.zip"><code class="docutils literal notranslate"><span class="pre">pizza_steak_sushi_20_percent.zip</span></code></a> dataset so we can train our previously best performing models on the same dataset.</p></td>
</tr>
<tr class="row-even"><td><p><strong>2. FoodVision Mini model deployment experiment outline</strong></p></td>
<td><p>Even on the third milestone project, we’re still going to be running multiple experiments to see which model (EffNetB2 or ViT) achieves closest to our goal metrics.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>3. Creating an EffNetB2 feature extractor</strong></p></td>
<td><p>An EfficientNetB2 feature extractor performed the best on our pizza, steak, sushi dataset in <a class="reference external" href="https://www.learnpytorch.io/07_pytorch_experiment_tracking/">07. PyTorch Experiment Tracking</a>, let’s recreate it as a candidate for deployment.</p></td>
</tr>
<tr class="row-even"><td><p><strong>4. Creating a ViT feature extractor</strong></p></td>
<td><p>A ViT feature extractor has been the best performing model yet on our pizza, steak, sushi dataset in <a class="reference external" href="https://www.learnpytorch.io/08_pytorch_paper_replicating/">08. PyTorch Paper Replicating</a>, let’s recreate it as a candidate for deployment alongside EffNetB2.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>5. Making predictions with our trained models and timing them</strong></p></td>
<td><p>We’ve built two of the best performing models yet, let’s make predictions with them and track their results.</p></td>
</tr>
<tr class="row-even"><td><p><strong>6. Comparing model results, prediction times and size</strong></p></td>
<td><p>Let’s compare our models to see which performs best with our goals.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>7. Bringing FoodVision Mini to life by creating a Gradio demo</strong></p></td>
<td><p>One of our models performs better than the other (in terms of our goals), so let’s turn it into a working app demo!</p></td>
</tr>
<tr class="row-even"><td><p><strong>8. Turning our FoodVision Mini Gradio demo into a deployable app</strong></p></td>
<td><p>Our Gradio app demo works locally, let’s prepare it for deployment!</p></td>
</tr>
<tr class="row-odd"><td><p><strong>9. Deploying our Gradio demo to HuggingFace Spaces</strong></p></td>
<td><p>Let’s take FoodVision Mini to the web and make it pubically accessible for all!</p></td>
</tr>
<tr class="row-even"><td><p><strong>10. Creating a BIG surprise</strong></p></td>
<td><p>We’ve built FoodVision Mini, time to step things up a notch.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>11. Deploying our BIG surprise</strong></p></td>
<td><p>Deploying one app was fun, how about we make it two?</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="where-can-you-get-help">
<h2>Where can you get help?<a class="headerlink" href="#where-can-you-get-help" title="Permalink to this heading">#</a></h2>
<p>All of the materials for this course <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning">are available on GitHub</a>.</p>
<p>If you run into trouble, you can ask a question on the course <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/discussions">GitHub Discussions page</a>.</p>
<p>And of course, there’s the <a class="reference external" href="https://pytorch.org/docs/stable/index.html">PyTorch documentation</a> and <a class="reference external" href="https://discuss.pytorch.org/">PyTorch developer forums</a>, a very helpful place for all things PyTorch.</p>
</section>
<section id="getting-setup">
<h2>0. Getting setup<a class="headerlink" href="#getting-setup" title="Permalink to this heading">#</a></h2>
<p>As we’ve done previously, let’s make sure we’ve got all of the modules we’ll need for this section.</p>
<p>We’ll import the Python scripts (such as <code class="docutils literal notranslate"><span class="pre">data_setup.py</span></code> and <code class="docutils literal notranslate"><span class="pre">engine.py</span></code>) we created in <a class="reference external" href="https://www.learnpytorch.io/05_pytorch_going_modular/">05. PyTorch Going Modular</a>.</p>
<p>To do so, we’ll download <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/tree/main/going_modular"><code class="docutils literal notranslate"><span class="pre">going_modular</span></code></a> directory from the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning"><code class="docutils literal notranslate"><span class="pre">pytorch-deep-learning</span></code> repository</a> (if we don’t already have it).</p>
<p>We’ll also get the <a class="reference external" href="https://github.com/TylerYep/torchinfo"><code class="docutils literal notranslate"><span class="pre">torchinfo</span></code></a> package if it’s not available.</p>
<p><code class="docutils literal notranslate"><span class="pre">torchinfo</span></code> will help later on to give us a visual representation of our model.</p>
<p>And since later on we’ll be using <code class="docutils literal notranslate"><span class="pre">torchvision</span></code> v0.13 package (available as of July 2022), we’ll make sure we’ve got the latest versions.</p>
<blockquote>
<div><p><strong>Note:</strong> If you’re using Google Colab, and you don’t have a GPU turned on yet, it’s now time to turn one on via <code class="docutils literal notranslate"><span class="pre">Runtime</span> <span class="pre">-&gt;</span> <span class="pre">Change</span> <span class="pre">runtime</span> <span class="pre">type</span> <span class="pre">-&gt;</span> <span class="pre">Hardware</span> <span class="pre">accelerator</span> <span class="pre">-&gt;</span> <span class="pre">GPU</span></code>.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># For this notebook to run with updated APIs, we need torch 1.12+ and torchvision 0.13+</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">torch</span>
    <span class="kn">import</span> <span class="nn">torchvision</span>
    <span class="k">assert</span> <span class="nb">int</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;torch version should be 1.12+&quot;</span>
    <span class="k">assert</span> <span class="nb">int</span><span class="p">(</span><span class="n">torchvision</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">13</span><span class="p">,</span> <span class="s2">&quot;torchvision version should be 0.13+&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;torch version: </span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;torchvision version: </span><span class="si">{</span><span class="n">torchvision</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] torch/torchvision versions not as required, installing nightly versions.&quot;</span><span class="p">)</span>
    <span class="o">!</span>pip3<span class="w"> </span>install<span class="w"> </span>-U<span class="w"> </span>torch<span class="w"> </span>torchvision<span class="w"> </span>torchaudio<span class="w"> </span>--extra-index-url<span class="w"> </span>https://download.pytorch.org/whl/cu113
    <span class="kn">import</span> <span class="nn">torch</span>
    <span class="kn">import</span> <span class="nn">torchvision</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;torch version: </span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;torchvision version: </span><span class="si">{</span><span class="n">torchvision</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch version: 1.13.0.dev20220824+cu113
torchvision version: 0.14.0.dev20220824+cu113
</pre></div>
</div>
</div>
</div>
<blockquote>
<div><p><strong>Note:</strong> If you’re using Google Colab and the cell above starts to install various software packages, you may have to restart your runtime after running the above cell. After restarting, you can run the cell again and verify you’ve got the right versions of <code class="docutils literal notranslate"><span class="pre">torch</span></code> and <code class="docutils literal notranslate"><span class="pre">torchvision</span></code>.</p>
</div></blockquote>
<p>Now we’ll continue with the regular imports, setting up device agnostic code and this time we’ll also get the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/helper_functions.py"><code class="docutils literal notranslate"><span class="pre">helper_functions.py</span></code></a> script from GitHub.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">helper_functions.py</span></code> script contains several functions we created in previous sections:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">set_seeds()</span></code> to set the random seeds (created in <a class="reference external" href="https://www.learnpytorch.io/07_pytorch_experiment_tracking/#create-a-helper-function-to-set-seeds">07. PyTorch Experiment Tracking section 0</a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">download_data()</span></code> to download a data source given a link (created in <a class="reference external" href="https://www.learnpytorch.io/07_pytorch_experiment_tracking/#1-get-data">07. PyTorch Experiment Tracking section 1</a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plot_loss_curves()</span></code> to inspect our model’s training results (created in <a class="reference external" href="https://www.learnpytorch.io/04_pytorch_custom_datasets/#78-plot-the-loss-curves-of-model-0">04. PyTorch Custom Datasets section 7.8</a>)</p></li>
</ul>
<blockquote>
<div><p><strong>Note:</strong> It may be a better idea for many of the functions in the <code class="docutils literal notranslate"><span class="pre">helper_functions.py</span></code> script to be merged into <code class="docutils literal notranslate"><span class="pre">going_modular/going_modular/utils.py</span></code>, perhaps that’s an extension you’d like to try.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Continue with regular imports</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torchvision</span>

<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">transforms</span>

<span class="c1"># Try to get torchinfo, install it if it doesn&#39;t work</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">torchinfo</span> <span class="kn">import</span> <span class="n">summary</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Couldn&#39;t find torchinfo... installing it.&quot;</span><span class="p">)</span>
    <span class="o">!</span>pip<span class="w"> </span>install<span class="w"> </span>-q<span class="w"> </span>torchinfo
    <span class="kn">from</span> <span class="nn">torchinfo</span> <span class="kn">import</span> <span class="n">summary</span>

<span class="c1"># Try to import the going_modular directory, download it from GitHub if it doesn&#39;t work</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">data_setup</span><span class="p">,</span> <span class="n">engine</span>
    <span class="kn">from</span> <span class="nn">helper_functions</span> <span class="kn">import</span> <span class="n">download_data</span><span class="p">,</span> <span class="n">set_seeds</span><span class="p">,</span> <span class="n">plot_loss_curves</span>
<span class="k">except</span><span class="p">:</span>
    <span class="c1"># Get the going_modular scripts</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[INFO] Couldn&#39;t find going_modular or helper_functions scripts... downloading them from GitHub.&quot;</span><span class="p">)</span>
    <span class="o">!</span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/thangckt/pytorch-deep-learning
    <span class="o">!</span>mv<span class="w"> </span>pytorch-deep-learning/going_modular<span class="w"> </span>.
    <span class="o">!</span>mv<span class="w"> </span>pytorch-deep-learning/helper_functions.py<span class="w"> </span>.<span class="w"> </span>#<span class="w"> </span>get<span class="w"> </span>the<span class="w"> </span>helper_functions.py<span class="w"> </span>script
    <span class="o">!</span>rm<span class="w"> </span>-rf<span class="w"> </span>pytorch-deep-learning
    <span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">data_setup</span><span class="p">,</span> <span class="n">engine</span>
    <span class="kn">from</span> <span class="nn">helper_functions</span> <span class="kn">import</span> <span class="n">download_data</span><span class="p">,</span> <span class="n">set_seeds</span><span class="p">,</span> <span class="n">plot_loss_curves</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we’ll setup device-agnostic code to make sure our models run on the GPU.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span>
<span class="n">device</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;cuda&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="getting-data">
<h2>1. Getting data<a class="headerlink" href="#getting-data" title="Permalink to this heading">#</a></h2>
<p>We left off in <a class="reference external" href="https://www.learnpytorch.io/08_pytorch_paper_replicating/#106-save-feature-extractor-vit-model-and-check-file-size">08. PyTorch Paper Replicating</a> comparing our own Vision Transformer (ViT) feature extractor model to the EfficientNetB2 (EffNetB2) feature extractor model we created in <a class="reference external" href="https://www.learnpytorch.io/07_pytorch_experiment_tracking/#9-load-in-the-best-model-and-make-predictions-with-it">07. PyTorch Experiment Tracking</a>.</p>
<p>And we found that there was a slight difference in the comparison.</p>
<p>The EffNetB2 model was trained on 20% of the pizza, steak and sushi data from Food101 where as the ViT model was trained on 10%.</p>
<p>Since our goal is to deploy the best model for our FoodVision Mini problem, let’s start by downloading the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/data/pizza_steak_sushi_20_percent.zip">20% pizza, steak and sushi dataset</a> and train an EffNetB2 feature extractor and ViT feature extractor on it and then compare the two models.</p>
<p>This way we’ll be comparing apples to apples (one model trained on a dataset to another model trained on the same dataset).</p>
<blockquote>
<div><p><strong>Note:</strong> The dataset we’re downloading is a sample of the entire <a class="reference external" href="https://pytorch.org/vision/main/generated/torchvision.datasets.Food101.html#food101">Food101 dataset</a> (101 food classes with 1,000 images each). More specifically, 20% refers to 20% of images from the pizza, steak and sushi classes selected at random. You can see how this dataset was created in <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/extras/04_custom_data_creation.ipynb"><code class="docutils literal notranslate"><span class="pre">extras/04_custom_data_creation.ipynb</span></code></a> and more details in <a class="reference external" href="https://www.learnpytorch.io/04_pytorch_custom_datasets/#1-get-data">04. PyTorch Custom Datasets section 1</a>.</p>
</div></blockquote>
<p>We can download the data using the <code class="docutils literal notranslate"><span class="pre">download_data()</span></code> function we created in <a class="reference external" href="https://www.learnpytorch.io/07_pytorch_experiment_tracking/#1-get-data">07. PyTorch Experiment Tracking section 1</a> from <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/helper_functions.py"><code class="docutils literal notranslate"><span class="pre">helper_functions.py</span></code></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Download pizza, steak, sushi images from GitHub</span>
<span class="n">data_20_percent_path</span> <span class="o">=</span> <span class="n">download_data</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="s2">&quot;https://github.com/thangckt/pytorch-deep-learning/raw/main/data/pizza_steak_sushi_20_percent.zip&quot;</span><span class="p">,</span>
                                     <span class="n">destination</span><span class="o">=</span><span class="s2">&quot;pizza_steak_sushi_20_percent&quot;</span><span class="p">)</span>

<span class="n">data_20_percent_path</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] data/pizza_steak_sushi_20_percent directory exists, skipping download.
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>PosixPath(&#39;data/pizza_steak_sushi_20_percent&#39;)
</pre></div>
</div>
</div>
</div>
<p>Wonderful!</p>
<p>Now we’ve got a dataset, let’s creat training and test paths.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup directory paths to train and test images</span>
<span class="n">train_dir</span> <span class="o">=</span> <span class="n">data_20_percent_path</span> <span class="o">/</span> <span class="s2">&quot;train&quot;</span>
<span class="n">test_dir</span> <span class="o">=</span> <span class="n">data_20_percent_path</span> <span class="o">/</span> <span class="s2">&quot;test&quot;</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="foodvision-mini-model-deployment-experiment-outline">
<h2>2. FoodVision Mini model deployment experiment outline<a class="headerlink" href="#foodvision-mini-model-deployment-experiment-outline" title="Permalink to this heading">#</a></h2>
<p>The ideal deployed model FoodVision Mini performs well and fast.</p>
<p>We’d like our model to perform as close to real-time as possible.</p>
<p>Real-time in this case being ~30FPS (frames per second) because that’s <a class="reference external" href="https://www.healthline.com/health/human-eye-fps">about how fast the human eye can see</a> (there is debate on this but let’s just use ~30FPS as our benchmark).</p>
<p>And for classifying three different classes (pizza, steak and sushi), we’d like a model that performs at 95%+ accuracy.</p>
<p>Of course, higher accuracy would be nice but this might sacrifice speed.</p>
<p>So our goals are:</p>
<ol class="arabic simple">
<li><p><strong>Performance</strong> - A model that performs at 95%+ accuracy.</p></li>
<li><p><strong>Speed</strong> - A model that can classify an image at ~30FPS (0.03 seconds inference time per image, also known as latency).</p></li>
</ol>
<img alt="foodvision mini goals in terms of performance and inference time." src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-model-deployments-speed-vs-inference.png" />
<p><em>FoodVision Mini deployment goals. We’d like a fast predicting well-performing model (because a slow app is boring).</em></p>
<p>We’ll put an emphasis on speed, meaning, we’d prefer a model performing at 90%+ accuracy at ~30FPS than a model performing 95%+ accuracy at 10FPS.</p>
<p>To try and achieve these results, let’s bring in our best performing models from the previous sections:</p>
<ol class="arabic simple">
<li><p><strong>EffNetB2 feature extractor</strong> (EffNetB2 for short) - originally created in <a class="reference external" href="https://www.learnpytorch.io/07_pytorch_experiment_tracking/#75-create-feature-extractor-models">07. PyTorch Experiment Tracking section 7.5</a> using <a class="reference external" href="https://pytorch.org/vision/stable/models/generated/torchvision.models.efficientnet_b2.html#efficientnet-b2"><code class="docutils literal notranslate"><span class="pre">torchvision.models.efficientnet_b2()</span></code></a> with adjusted <code class="docutils literal notranslate"><span class="pre">classifier</span></code> layers.</p></li>
<li><p><strong>ViT-B/16 feature extractor</strong> (ViT for short) - originally created in <a class="reference external" href="https://www.learnpytorch.io/08_pytorch_paper_replicating/#10-using-a-pretrained-vit-from-torchvisionmodels-on-the-same-dataset">08. PyTorch Paper Replicating section 10</a> using <a class="reference external" href="https://pytorch.org/vision/stable/models/generated/torchvision.models.vit_b_16.html#vit-b-16"><code class="docutils literal notranslate"><span class="pre">torchvision.models.vit_b_16()</span></code></a> with adjusted <code class="docutils literal notranslate"><span class="pre">head</span></code> layers.</p>
<ul class="simple">
<li><p><strong>Note</strong> ViT-B/16 stands for “Vision Transformer Base, patch size 16”.</p></li>
</ul>
</li>
</ol>
<img alt="modelling experiments for foodvision mini deployments, one effnetb2 feature extractor model and a vision transformer feature extractor model" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-model-deployment-two-experiments.png" />
<blockquote>
<div><p><strong>Note:</strong> A “feature extractor model” often starts with a model that has been pretrained on a dataset similar to your own problem. The pretrained model’s base layers are often left frozen (the pretrained patterns/weights stay the same) whilst some of the top (or classifier/classification head) layers get customized to your own problem by training on your own data. We covered the concept of a feature extractor model in <a class="reference external" href="https://www.learnpytorch.io/06_pytorch_transfer_learning/#34-freezing-the-base-model-and-changing-the-output-layer-to-suit-our-needs">06. PyTorch Transfer Learning section 3.4</a>.</p>
</div></blockquote>
</section>
<section id="creating-an-effnetb2-feature-extractor">
<h2>3. Creating an EffNetB2 feature extractor<a class="headerlink" href="#creating-an-effnetb2-feature-extractor" title="Permalink to this heading">#</a></h2>
<p>We first created an EffNetB2 feature extractor model in <a class="reference external" href="https://www.learnpytorch.io/07_pytorch_experiment_tracking/#75-create-feature-extractor-models">07. PyTorch Experiment Tracking section 7.5</a>.</p>
<p>And by the end of that section we saw it performed very well.</p>
<p>So let’s now recreate it here so we can compare its results to a ViT feature extractor trained on the same data.</p>
<p>To do so we can:</p>
<ol class="arabic simple">
<li><p>Setup the pretrained weights as <a class="reference external" href="https://pytorch.org/vision/stable/models/generated/torchvision.models.efficientnet_b2.html#torchvision.models.EfficientNet_B2_Weights"><code class="docutils literal notranslate"><span class="pre">weights=torchvision.models.EfficientNet_B2_Weights.DEFAULT</span></code></a>, where “<code class="docutils literal notranslate"><span class="pre">DEFAULT</span></code>” means “best currently available” (or could use <code class="docutils literal notranslate"><span class="pre">weights=&quot;DEFAULT&quot;</span></code>).</p></li>
<li><p>Get the pretrained model image transforms from the weights with the <code class="docutils literal notranslate"><span class="pre">transforms()</span></code> method (we need these so we can convert our images into the same format as the pretrained EffNetB2 was trained on).</p></li>
<li><p>Create a pretrained model instance by passing the weights to an instance of <a class="reference external" href="https://pytorch.org/vision/stable/models/generated/torchvision.models.efficientnet_b2.html#efficientnet-b2"><code class="docutils literal notranslate"><span class="pre">torchvision.models.efficientnet_b2</span></code></a>.</p></li>
<li><p>Freeze the base layers in the model.</p></li>
<li><p>Update the classifier head to suit our own data.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 1. Setup pretrained EffNetB2 weights</span>
<span class="n">effnetb2_weights</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">EfficientNet_B2_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>

<span class="c1"># 2. Get EffNetB2 transforms</span>
<span class="n">effnetb2_transforms</span> <span class="o">=</span> <span class="n">effnetb2_weights</span><span class="o">.</span><span class="n">transforms</span><span class="p">()</span>

<span class="c1"># 3. Setup pretrained model</span>
<span class="n">effnetb2</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">efficientnet_b2</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">effnetb2_weights</span><span class="p">)</span> <span class="c1"># could also use weights=&quot;DEFAULT&quot;</span>

<span class="c1"># 4. Freeze the base layers in the model (this will freeze all layers to begin with)</span>
<span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">effnetb2</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
    <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<p>Now to change the classifier head, let’s first inspect it using the <code class="docutils literal notranslate"><span class="pre">classifier</span></code> attribute of our model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check out EffNetB2 classifier head</span>
<span class="n">effnetb2</span><span class="o">.</span><span class="n">classifier</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Sequential(
  (0): Dropout(p=0.3, inplace=True)
  (1): Linear(in_features=1408, out_features=1000, bias=True)
)
</pre></div>
</div>
</div>
</div>
<p>Excellent! To change the classifier head to suit our own problem, let’s replace the <code class="docutils literal notranslate"><span class="pre">out_features</span></code> variable with the same number of classes we have (in our case, <code class="docutils literal notranslate"><span class="pre">out_features=3</span></code>, one for pizza, steak, sushi).</p>
<blockquote>
<div><p><strong>Note:</strong> This process of changing the output layers/classifier head will be dependent on the problem you’re working on. For example, if you wanted a different <em>number</em> of outputs or a different <em>kind</em> of ouput, you would have to change the output layers accordingly.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 5. Update the classifier head</span>
<span class="n">effnetb2</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
    <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="c1"># keep dropout layer same</span>
    <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">1408</span><span class="p">,</span> <span class="c1"># keep in_features same </span>
              <span class="n">out_features</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># change out_features to suit our number of classes</span>
</pre></div>
</div>
</div>
</div>
<p>Beautiful!</p>
<section id="creating-a-function-to-make-an-effnetb2-feature-extractor">
<h3>3.1 Creating a function to make an EffNetB2 feature extractor<a class="headerlink" href="#creating-a-function-to-make-an-effnetb2-feature-extractor" title="Permalink to this heading">#</a></h3>
<p>Looks like our EffNetB2 feature extractor is ready to go, however, since there’s quite a few steps involved here, how about we turn the code above into a function we can re-use later?</p>
<p>We’ll call it <code class="docutils literal notranslate"><span class="pre">create_effnetb2_model()</span></code> and it’ll take a customizable number of classes and a random seed parameter for reproducibility.</p>
<p>Ideally, it will return an EffNetB2 feature extractor along with its assosciated transforms.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_effnetb2_model</span><span class="p">(</span><span class="n">num_classes</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                          <span class="n">seed</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates an EfficientNetB2 feature extractor model and transforms.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_classes (int, optional): number of classes in the classifier head. </span>
<span class="sd">            Defaults to 3.</span>
<span class="sd">        seed (int, optional): random seed value. Defaults to 42.</span>

<span class="sd">    Returns:</span>
<span class="sd">        model (torch.nn.Module): EffNetB2 feature extractor model. </span>
<span class="sd">        transforms (torchvision.transforms): EffNetB2 image transforms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1, 2, 3. Create EffNetB2 pretrained weights, transforms and model</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">EfficientNet_B2_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
    <span class="n">transforms</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">transforms</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">efficientnet_b2</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># 4. Freeze all layers in base model</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
        <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># 5. Change classifier head with random seed for reproducibility</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">1408</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="n">num_classes</span><span class="p">),</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">transforms</span>
</pre></div>
</div>
</div>
</div>
<p>Woohoo! That’s a nice looking function, let’s try it out.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">effnetb2</span><span class="p">,</span> <span class="n">effnetb2_transforms</span> <span class="o">=</span> <span class="n">create_effnetb2_model</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                                      <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>No errors, nice, now to really try it out, let’s get a summary with <code class="docutils literal notranslate"><span class="pre">torchinfo.summary()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torchinfo</span> <span class="kn">import</span> <span class="n">summary</span>

<span class="c1"># # Print EffNetB2 model summary (uncomment for full output) </span>
<span class="c1"># summary(effnetb2, </span>
<span class="c1">#         input_size=(1, 3, 224, 224),</span>
<span class="c1">#         col_names=[&quot;input_size&quot;, &quot;output_size&quot;, &quot;num_params&quot;, &quot;trainable&quot;],</span>
<span class="c1">#         col_width=20,</span>
<span class="c1">#         row_settings=[&quot;var_names&quot;])</span>
</pre></div>
</div>
</div>
</div>
<img alt="effnetb2 feature extractor model summary" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-effnetb2-feature-extractor.png" />
<p>Base layers frozen, top layers trainable and customized!</p>
</section>
<section id="creating-dataloaders-for-effnetb2">
<h3>3.2 Creating DataLoaders for EffNetB2<a class="headerlink" href="#creating-dataloaders-for-effnetb2" title="Permalink to this heading">#</a></h3>
<p>Our EffNetB2 feature extractor is ready, time to create some <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>s.</p>
<p>We can do this by using the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/going_modular/going_modular/data_setup.py"><code class="docutils literal notranslate"><span class="pre">data_setup.create_dataloaders()</span></code></a> function we created in <a class="reference external" href="https://www.learnpytorch.io/05_pytorch_going_modular/#2-create-datasets-and-dataloaders-data_setuppy">05. PyTorch Going Modular section 2</a>.</p>
<p>We’ll use a <code class="docutils literal notranslate"><span class="pre">batch_size</span></code> of 32 and transform our images using the <code class="docutils literal notranslate"><span class="pre">effnetb2_transforms</span></code> so they’re in the same format that our <code class="docutils literal notranslate"><span class="pre">effnetb2</span></code> model was trained on.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup DataLoaders</span>
<span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">data_setup</span>
<span class="n">train_dataloader_effnetb2</span><span class="p">,</span> <span class="n">test_dataloader_effnetb2</span><span class="p">,</span> <span class="n">class_names</span> <span class="o">=</span> <span class="n">data_setup</span><span class="o">.</span><span class="n">create_dataloaders</span><span class="p">(</span><span class="n">train_dir</span><span class="o">=</span><span class="n">train_dir</span><span class="p">,</span>
                                                                                                 <span class="n">test_dir</span><span class="o">=</span><span class="n">test_dir</span><span class="p">,</span>
                                                                                                 <span class="n">transform</span><span class="o">=</span><span class="n">effnetb2_transforms</span><span class="p">,</span>
                                                                                                 <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="training-effnetb2-feature-extractor">
<h3>3.3 Training EffNetB2 feature extractor<a class="headerlink" href="#training-effnetb2-feature-extractor" title="Permalink to this heading">#</a></h3>
<p>Model ready, <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>s ready, let’s train!</p>
<p>Just like in <a class="reference external" href="https://www.learnpytorch.io/07_pytorch_experiment_tracking/#76-create-experiments-and-set-up-training-code">07. PyTorch Experiment Tracking section 7.6</a>, ten epochs should be enough to get good results.</p>
<p>We can do so by creating an optimizer (we’ll use <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.optim.Adam.html#torch.optim.Adam"><code class="docutils literal notranslate"><span class="pre">torch.optim.Adam()</span></code></a> with a learning rate of <code class="docutils literal notranslate"><span class="pre">1e-3</span></code>), a loss function (we’ll use <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html"><code class="docutils literal notranslate"><span class="pre">torch.nn.CrossEntropyLoss()</span></code></a> for multi-class classification) and then passing these as well as our <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>s to the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/going_modular/going_modular/engine.py"><code class="docutils literal notranslate"><span class="pre">engine.train()</span></code></a> function we created in <a class="reference external" href="https://www.learnpytorch.io/05_pytorch_going_modular/#4-creating-train_step-and-test_step-functions-and-train-to-combine-them">05. PyTorch Going Modular section 4</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">engine</span>

<span class="c1"># Setup optimizer</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">effnetb2</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span>
                             <span class="n">lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
<span class="c1"># Setup loss function</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">()</span>

<span class="c1"># Set seeds for reproducibility and train the model</span>
<span class="n">set_seeds</span><span class="p">()</span>
<span class="n">effnetb2_results</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">effnetb2</span><span class="p">,</span>
                                <span class="n">train_dataloader</span><span class="o">=</span><span class="n">train_dataloader_effnetb2</span><span class="p">,</span>
                                <span class="n">test_dataloader</span><span class="o">=</span><span class="n">test_dataloader_effnetb2</span><span class="p">,</span>
                                <span class="n">epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
                                <span class="n">loss_fn</span><span class="o">=</span><span class="n">loss_fn</span><span class="p">,</span>
                                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "128923b0faf94e0591a606c01403fbb5", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Epoch: 1 | train_loss: 0.9856 | train_acc: 0.5604 | test_loss: 0.7408 | test_acc: 0.9347
Epoch: 2 | train_loss: 0.7175 | train_acc: 0.8438 | test_loss: 0.5869 | test_acc: 0.9409
Epoch: 3 | train_loss: 0.5876 | train_acc: 0.8917 | test_loss: 0.4909 | test_acc: 0.9500
Epoch: 4 | train_loss: 0.4474 | train_acc: 0.9062 | test_loss: 0.4355 | test_acc: 0.9409
Epoch: 5 | train_loss: 0.4290 | train_acc: 0.9104 | test_loss: 0.3915 | test_acc: 0.9443
Epoch: 6 | train_loss: 0.4381 | train_acc: 0.8896 | test_loss: 0.3512 | test_acc: 0.9688
Epoch: 7 | train_loss: 0.4245 | train_acc: 0.8771 | test_loss: 0.3268 | test_acc: 0.9563
Epoch: 8 | train_loss: 0.3897 | train_acc: 0.8958 | test_loss: 0.3457 | test_acc: 0.9381
Epoch: 9 | train_loss: 0.3749 | train_acc: 0.8812 | test_loss: 0.3129 | test_acc: 0.9131
Epoch: 10 | train_loss: 0.3757 | train_acc: 0.8604 | test_loss: 0.2813 | test_acc: 0.9688
</pre></div>
</div>
</div>
</div>
</section>
<section id="inspecting-effnetb2-loss-curves">
<h3>3.4 Inspecting EffNetB2 loss curves<a class="headerlink" href="#inspecting-effnetb2-loss-curves" title="Permalink to this heading">#</a></h3>
<p>Nice!</p>
<p>As we saw in 07. PyTorch Experiment Tracking, the EffNetB2 feature extractor model works quite well on our data.</p>
<p>Let’s turn its results into loss curves to inspect them further.</p>
<blockquote>
<div><p><strong>Note:</strong> Loss curves are one of the best ways to visualize how your model’s performing. For more on loss curves, check out <a class="reference external" href="https://www.learnpytorch.io/04_pytorch_custom_datasets/#8-what-should-an-ideal-loss-curve-look-like">04. PyTorch Custom Datasets section 8: What should an ideal loss curve look like?</a></p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">helper_functions</span> <span class="kn">import</span> <span class="n">plot_loss_curves</span>

<span class="n">plot_loss_curves</span><span class="p">(</span><span class="n">effnetb2_results</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/7948b8a5d1f57258e0da25b4d3584bc3258ca04ac531e66e1c9a802123b5e598.png" src="../../_images/7948b8a5d1f57258e0da25b4d3584bc3258ca04ac531e66e1c9a802123b5e598.png" />
</div>
</div>
<p>Woah!</p>
<p>Those are some nice looking loss curves.</p>
<p>It looks like our model is performing quite well and perhaps would benefit from a little longer training and potentially some <a class="reference external" href="https://www.learnpytorch.io/04_pytorch_custom_datasets/#6-other-forms-of-transforms-data-augmentation">data augmentation</a> (to help prevent potential overfitting occurring from longer training).</p>
</section>
<section id="saving-effnetb2-feature-extractor">
<h3>3.5 Saving EffNetB2 feature extractor<a class="headerlink" href="#saving-effnetb2-feature-extractor" title="Permalink to this heading">#</a></h3>
<p>Now we’ve got a well-performing trained model, let’s save it to file so we can import and use it later.</p>
<p>To save our model we can use the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/going_modular/going_modular/utils.py"><code class="docutils literal notranslate"><span class="pre">utils.save_model()</span></code></a> function we created in <a class="reference external" href="https://www.learnpytorch.io/05_pytorch_going_modular/#5-creating-a-function-to-save-the-model-utilspy">05. PyTorch Going Modular section 5</a>.</p>
<p>We’ll set the <code class="docutils literal notranslate"><span class="pre">target_dir</span></code> to <code class="docutils literal notranslate"><span class="pre">&quot;models&quot;</span></code> and the <code class="docutils literal notranslate"><span class="pre">model_name</span></code> to <code class="docutils literal notranslate"><span class="pre">&quot;09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth&quot;</span></code> (a little comprehensive but at least we know what’s going on).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="c1"># Save the model</span>
<span class="n">utils</span><span class="o">.</span><span class="n">save_model</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">effnetb2</span><span class="p">,</span>
                 <span class="n">target_dir</span><span class="o">=</span><span class="s2">&quot;models&quot;</span><span class="p">,</span>
                 <span class="n">model_name</span><span class="o">=</span><span class="s2">&quot;09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] Saving model to: models/09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth
</pre></div>
</div>
</div>
</div>
</section>
<section id="checking-the-size-of-effnetb2-feature-extractor">
<h3>3.6 Checking the size of EffNetB2 feature extractor<a class="headerlink" href="#checking-the-size-of-effnetb2-feature-extractor" title="Permalink to this heading">#</a></h3>
<p>Since one of our criteria for deploying a model to power FoodVision Mini is <strong>speed</strong> (~30FPS or better), let’s check the size of our model.</p>
<p>Why check the size?</p>
<p>Well, while not always the case, the size of a model can influence its inference speed.</p>
<p>As in, if a model has more parameters, it generally performs more operations and each one of these operations requires some computing power.</p>
<p>And because we’d like our model to work on devices with limited computing power (e.g. on a mobile device or in a web browser), generally, the smaller the size the better (as long as it still performs well in terms of accuracy).</p>
<p>To check our model’s size in bytes, we can use Python’s <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat"><code class="docutils literal notranslate"><span class="pre">pathlib.Path.stat(&quot;path_to_model&quot;).st_size</span></code></a> and then we can convert it (roughly) to megabytes by dividing it by <code class="docutils literal notranslate"><span class="pre">(1024*1024)</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># Get the model size in bytes then convert to megabytes</span>
<span class="n">pretrained_effnetb2_model_size</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;models/09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span> <span class="o">//</span> <span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="c1"># division converts bytes to megabytes (roughly) </span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pretrained EffNetB2 feature extractor model size: </span><span class="si">{</span><span class="n">pretrained_effnetb2_model_size</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Pretrained EffNetB2 feature extractor model size: 29 MB
</pre></div>
</div>
</div>
</div>
</section>
<section id="collecting-effnetb2-feature-extractor-stats">
<h3>3.7 Collecting EffNetB2 feature extractor stats<a class="headerlink" href="#collecting-effnetb2-feature-extractor-stats" title="Permalink to this heading">#</a></h3>
<p>We’ve got a few statistics about our EffNetB2 feature extractor model such as test loss, test accuracy and model size, how about we collect them all in a dictionary so we can compare them to the upcoming ViT feature extractor.</p>
<p>And we’ll calculate an extra one for fun, total number of parameters.</p>
<p>We can do so by counting the number of elements (or patterns/weights) in <code class="docutils literal notranslate"><span class="pre">effnetb2.parameters()</span></code>. We’ll access the number of elements in each parameter using the <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.numel.html"><code class="docutils literal notranslate"><span class="pre">torch.numel()</span></code></a> (short for “number of elements”) method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Count number of parameters in EffNetB2</span>
<span class="n">effnetb2_total_params</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">numel</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">effnetb2</span><span class="o">.</span><span class="n">parameters</span><span class="p">())</span>
<span class="n">effnetb2_total_params</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>7705221
</pre></div>
</div>
</div>
</div>
<p>Excellent!</p>
<p>Now let’s put everything in a dictionary so we can make comparisons later on.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a dictionary with EffNetB2 statistics</span>
<span class="n">effnetb2_stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;test_loss&quot;</span><span class="p">:</span> <span class="n">effnetb2_results</span><span class="p">[</span><span class="s2">&quot;test_loss&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                  <span class="s2">&quot;test_acc&quot;</span><span class="p">:</span> <span class="n">effnetb2_results</span><span class="p">[</span><span class="s2">&quot;test_acc&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                  <span class="s2">&quot;number_of_parameters&quot;</span><span class="p">:</span> <span class="n">effnetb2_total_params</span><span class="p">,</span>
                  <span class="s2">&quot;model_size (MB)&quot;</span><span class="p">:</span> <span class="n">pretrained_effnetb2_model_size</span><span class="p">}</span>
<span class="n">effnetb2_stats</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;test_loss&#39;: 0.28128674924373626,
 &#39;test_acc&#39;: 0.96875,
 &#39;number_of_parameters&#39;: 7705221,
 &#39;model_size (MB)&#39;: 29}
</pre></div>
</div>
</div>
</div>
<p>Epic!</p>
<p>Looks like our EffNetB2 model is performing at over 95% accuracy!</p>
<p>Criteria number 1: perform at 95%+ accuracy, tick!</p>
</section>
</section>
<section id="creating-a-vit-feature-extractor">
<h2>4. Creating a ViT feature extractor<a class="headerlink" href="#creating-a-vit-feature-extractor" title="Permalink to this heading">#</a></h2>
<p>Time to continue with our FoodVision Mini modelling experiments.</p>
<p>This time we’re going to create a ViT feature extractor.</p>
<p>And we’ll do it in much the same way as the EffNetB2 feature extractor except this time with <a class="reference external" href="https://pytorch.org/vision/stable/models/generated/torchvision.models.vit_b_16.html#torchvision.models.vit_b_16"><code class="docutils literal notranslate"><span class="pre">torchvision.models.vit_b_16()</span></code></a> instead of <code class="docutils literal notranslate"><span class="pre">torchvision.models.efficientnet_b2()</span></code>.</p>
<p>We’ll start by creating a function called <code class="docutils literal notranslate"><span class="pre">create_vit_model()</span></code> which will be very similar to <code class="docutils literal notranslate"><span class="pre">create_effnetb2_model()</span></code> except of course returning a ViT feature extractor model and transforms rather than EffNetB2.</p>
<p>Another slight difference is that <code class="docutils literal notranslate"><span class="pre">torchvision.models.vit_b_16()</span></code>’s output layer is called <code class="docutils literal notranslate"><span class="pre">heads</span></code> rather than <code class="docutils literal notranslate"><span class="pre">classifier</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check out ViT heads layer</span>
<span class="n">vit</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">vit_b_16</span><span class="p">()</span>
<span class="n">vit</span><span class="o">.</span><span class="n">heads</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Sequential(
  (head): Linear(in_features=768, out_features=1000, bias=True)
)
</pre></div>
</div>
</div>
</div>
<p>Knowing this, we’ve got all the pieces of the puzzle we need.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_vit_model</span><span class="p">(</span><span class="n">num_classes</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                     <span class="n">seed</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a ViT-B/16 feature extractor model and transforms.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_classes (int, optional): number of target classes. Defaults to 3.</span>
<span class="sd">        seed (int, optional): random seed value for output layer. Defaults to 42.</span>

<span class="sd">    Returns:</span>
<span class="sd">        model (torch.nn.Module): ViT-B/16 feature extractor model. </span>
<span class="sd">        transforms (torchvision.transforms): ViT-B/16 image transforms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create ViT_B_16 pretrained weights, transforms and model</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ViT_B_16_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
    <span class="n">transforms</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">transforms</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">vit_b_16</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Freeze all layers in model</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
        <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Change classifier head to suit our needs (this will be trainable)</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">heads</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">768</span><span class="p">,</span> <span class="c1"># keep this the same as original model</span>
                                          <span class="n">out_features</span><span class="o">=</span><span class="n">num_classes</span><span class="p">))</span> <span class="c1"># update to reflect target number of classes</span>
    
    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">transforms</span>
</pre></div>
</div>
</div>
</div>
<p>ViT feature extraction model creation function ready!</p>
<p>Let’s test it out.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create ViT model and transforms</span>
<span class="n">vit</span><span class="p">,</span> <span class="n">vit_transforms</span> <span class="o">=</span> <span class="n">create_vit_model</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                       <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>No errors, lovely to see!</p>
<p>Now let’s get a nice-looking summary of our ViT model using <code class="docutils literal notranslate"><span class="pre">torchinfo.summary()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torchinfo</span> <span class="kn">import</span> <span class="n">summary</span>

<span class="c1"># # Print ViT feature extractor model summary (uncomment for full output)</span>
<span class="c1"># summary(vit, </span>
<span class="c1">#         input_size=(1, 3, 224, 224),</span>
<span class="c1">#         col_names=[&quot;input_size&quot;, &quot;output_size&quot;, &quot;num_params&quot;, &quot;trainable&quot;],</span>
<span class="c1">#         col_width=20,</span>
<span class="c1">#         row_settings=[&quot;var_names&quot;])</span>
</pre></div>
</div>
</div>
</div>
<img alt="vit feature extractor with 3 output classes" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-vit-feature-extractor-3-classes.png" />
<p>Just like our EffNetB2 feature extractor model, our ViT model’s base layers are frozen and the output layer is customized to our needs!</p>
<p>Do you notice the big difference though?</p>
<p>Our ViT model has <em>far</em> more parameters than our EffNetB2 model. Perhaps this will come into play when we compare are our models across speed and performance later on.</p>
<section id="create-dataloaders-for-vit">
<h3>4.1 Create DataLoaders for ViT<a class="headerlink" href="#create-dataloaders-for-vit" title="Permalink to this heading">#</a></h3>
<p>We’ve got our ViT model ready, now let’s create some <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>s for it.</p>
<p>We’ll do this in the same way we did for EffNetB2 except we’ll use <code class="docutils literal notranslate"><span class="pre">vit_transforms</span></code> to transform our images into the same format the ViT model was trained on.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup ViT DataLoaders</span>
<span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">data_setup</span>
<span class="n">train_dataloader_vit</span><span class="p">,</span> <span class="n">test_dataloader_vit</span><span class="p">,</span> <span class="n">class_names</span> <span class="o">=</span> <span class="n">data_setup</span><span class="o">.</span><span class="n">create_dataloaders</span><span class="p">(</span><span class="n">train_dir</span><span class="o">=</span><span class="n">train_dir</span><span class="p">,</span>
                                                                                       <span class="n">test_dir</span><span class="o">=</span><span class="n">test_dir</span><span class="p">,</span>
                                                                                       <span class="n">transform</span><span class="o">=</span><span class="n">vit_transforms</span><span class="p">,</span>
                                                                                       <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="training-vit-feature-extractor">
<h3>4.2 Training ViT feature extractor<a class="headerlink" href="#training-vit-feature-extractor" title="Permalink to this heading">#</a></h3>
<p>You know what time it is…</p>
<p>…it’s traininggggggg time (sung in the same tune as the song <a class="reference external" href="https://youtu.be/xGytDsqkQY8">Closing Time</a>).</p>
<p>Let’s train our ViT feature extractor model for 10 epochs using our <code class="docutils literal notranslate"><span class="pre">engine.train()</span></code> function with <code class="docutils literal notranslate"><span class="pre">torch.optim.Adam()</span></code> and a learning rate of <code class="docutils literal notranslate"><span class="pre">1e-3</span></code> as our optimizer and <code class="docutils literal notranslate"><span class="pre">torch.nn.CrossEntropyLoss()</span></code> as our loss function.</p>
<p>We’ll use our <code class="docutils literal notranslate"><span class="pre">set_seeds()</span></code> function before training to try and make our results as reproducible as possible.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">engine</span>

<span class="c1"># Setup optimizer</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">vit</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span>
                             <span class="n">lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
<span class="c1"># Setup loss function</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">()</span>

<span class="c1"># Train ViT model with seeds set for reproducibility</span>
<span class="n">set_seeds</span><span class="p">()</span>
<span class="n">vit_results</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">vit</span><span class="p">,</span>
                           <span class="n">train_dataloader</span><span class="o">=</span><span class="n">train_dataloader_vit</span><span class="p">,</span>
                           <span class="n">test_dataloader</span><span class="o">=</span><span class="n">test_dataloader_vit</span><span class="p">,</span>
                           <span class="n">epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                           <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
                           <span class="n">loss_fn</span><span class="o">=</span><span class="n">loss_fn</span><span class="p">,</span>
                           <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "ded441208c9540c28035eb5ea07b4b39", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Epoch: 1 | train_loss: 0.7023 | train_acc: 0.7500 | test_loss: 0.2714 | test_acc: 0.9290
Epoch: 2 | train_loss: 0.2531 | train_acc: 0.9104 | test_loss: 0.1669 | test_acc: 0.9602
Epoch: 3 | train_loss: 0.1766 | train_acc: 0.9542 | test_loss: 0.1270 | test_acc: 0.9693
Epoch: 4 | train_loss: 0.1277 | train_acc: 0.9625 | test_loss: 0.1072 | test_acc: 0.9722
Epoch: 5 | train_loss: 0.1163 | train_acc: 0.9646 | test_loss: 0.0950 | test_acc: 0.9784
Epoch: 6 | train_loss: 0.1270 | train_acc: 0.9375 | test_loss: 0.0830 | test_acc: 0.9722
Epoch: 7 | train_loss: 0.0899 | train_acc: 0.9771 | test_loss: 0.0844 | test_acc: 0.9784
Epoch: 8 | train_loss: 0.0928 | train_acc: 0.9812 | test_loss: 0.0759 | test_acc: 0.9722
Epoch: 9 | train_loss: 0.0933 | train_acc: 0.9792 | test_loss: 0.0729 | test_acc: 0.9784
Epoch: 10 | train_loss: 0.0662 | train_acc: 0.9833 | test_loss: 0.0642 | test_acc: 0.9847
</pre></div>
</div>
</div>
</div>
</section>
<section id="inspecting-vit-loss-curves">
<h3>4.3 Inspecting ViT loss curves<a class="headerlink" href="#inspecting-vit-loss-curves" title="Permalink to this heading">#</a></h3>
<p>Alright, alright, alright, ViT model trained, let’s get visual and see some loss curves.</p>
<blockquote>
<div><p><strong>Note:</strong> Don’t forget you can see what an ideal set of loss curves should look like in <a class="reference external" href="https://www.learnpytorch.io/04_pytorch_custom_datasets/#8-what-should-an-ideal-loss-curve-look-like">04. PyTorch Custom Datasets section 8</a>.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">helper_functions</span> <span class="kn">import</span> <span class="n">plot_loss_curves</span>

<span class="n">plot_loss_curves</span><span class="p">(</span><span class="n">vit_results</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/d081a4aacd57b25bd573c4f4331e569a810c261101f7d733fbaacc8578ff183d.png" src="../../_images/d081a4aacd57b25bd573c4f4331e569a810c261101f7d733fbaacc8578ff183d.png" />
</div>
</div>
<p>Ohh yeah!</p>
<p>Those are some nice looking loss curves. Just like our EffNetB2 feature extractor model, it looks our ViT model might benefit from a little longer training time and perhaps some <a class="reference external" href="https://www.learnpytorch.io/04_pytorch_custom_datasets/#6-other-forms-of-transforms-data-augmentation">data augmentation</a> (to help prevent overfitting).</p>
</section>
<section id="saving-vit-feature-extractor">
<h3>4.4 Saving ViT feature extractor<a class="headerlink" href="#saving-vit-feature-extractor" title="Permalink to this heading">#</a></h3>
<p>Our ViT model is performing outstanding!</p>
<p>So let’s save it to file so we can import it and use it later if we wish.</p>
<p>We can do so using the <code class="docutils literal notranslate"><span class="pre">utils.save_model()</span></code> function we created in <a class="reference external" href="https://www.learnpytorch.io/05_pytorch_going_modular/#5-creating-a-function-to-save-the-model-utilspy">05. PyTorch Going Modular section 5</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Save the model</span>
<span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="n">utils</span><span class="o">.</span><span class="n">save_model</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">vit</span><span class="p">,</span>
                 <span class="n">target_dir</span><span class="o">=</span><span class="s2">&quot;models&quot;</span><span class="p">,</span>
                 <span class="n">model_name</span><span class="o">=</span><span class="s2">&quot;09_pretrained_vit_feature_extractor_pizza_steak_sushi_20_percent.pth&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] Saving model to: models/09_pretrained_vit_feature_extractor_pizza_steak_sushi_20_percent.pth
</pre></div>
</div>
</div>
</div>
</section>
<section id="checking-the-size-of-vit-feature-extractor">
<h3>4.5 Checking the size of ViT feature extractor<a class="headerlink" href="#checking-the-size-of-vit-feature-extractor" title="Permalink to this heading">#</a></h3>
<p>And since we want to compare our EffNetB2 model to our ViT model across a number of characteristics, let’s find out its size.</p>
<p>To check our model’s size in bytes, we can use Python’s <code class="docutils literal notranslate"><span class="pre">pathlib.Path.stat(&quot;path_to_model&quot;).st_size</span></code> and then we can convert it (roughly) to megabytes by dividing it by <code class="docutils literal notranslate"><span class="pre">(1024*1024)</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># Get the model size in bytes then convert to megabytes</span>
<span class="n">pretrained_vit_model_size</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;models/09_pretrained_vit_feature_extractor_pizza_steak_sushi_20_percent.pth&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span> <span class="o">//</span> <span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="c1"># division converts bytes to megabytes (roughly) </span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pretrained ViT feature extractor model size: </span><span class="si">{</span><span class="n">pretrained_vit_model_size</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Pretrained ViT feature extractor model size: 327 MB
</pre></div>
</div>
</div>
</div>
<p>Hmm, how does the ViT feature extractor model size compare to our EffNetB2 model size?</p>
<p>We’ll find this out shortly when we compare all of our model’s characteristics.</p>
</section>
<section id="collecting-vit-feature-extractor-stats">
<h3>4.6 Collecting ViT feature extractor stats<a class="headerlink" href="#collecting-vit-feature-extractor-stats" title="Permalink to this heading">#</a></h3>
<p>Let’s put together all of our ViT feature extractor model statistics.</p>
<p>We saw it in the summary output above but we’ll calculate its total number of parameters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Count number of parameters in ViT</span>
<span class="n">vit_total_params</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">numel</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">vit</span><span class="o">.</span><span class="n">parameters</span><span class="p">())</span>
<span class="n">vit_total_params</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>85800963
</pre></div>
</div>
</div>
</div>
<p>Woah, that looks like a fair bit more than our EffNetB2!</p>
<blockquote>
<div><p><strong>Note:</strong> A larger number of parameters (or weights/patterns) generally means a model has a higher <em>capacity</em> to learn, whether it actually uses this extra capacity is another story. In light of this, our EffNetB2 model has 7,705,221 parameters where as our ViT model has 85,800,963 (11.1x more) so we could assume that our ViT model has more of a capacity to learn, if given more data (more opportunities to learn). However, this larger capacity to learn ofen comes with an  increased model filesize and a longer time to perform inference.</p>
</div></blockquote>
<p>Now let’s create a dictionary with some important characteristics of our ViT model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create ViT statistics dictionary</span>
<span class="n">vit_stats</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;test_loss&quot;</span><span class="p">:</span> <span class="n">vit_results</span><span class="p">[</span><span class="s2">&quot;test_loss&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
             <span class="s2">&quot;test_acc&quot;</span><span class="p">:</span> <span class="n">vit_results</span><span class="p">[</span><span class="s2">&quot;test_acc&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
             <span class="s2">&quot;number_of_parameters&quot;</span><span class="p">:</span> <span class="n">vit_total_params</span><span class="p">,</span>
             <span class="s2">&quot;model_size (MB)&quot;</span><span class="p">:</span> <span class="n">pretrained_vit_model_size</span><span class="p">}</span>

<span class="n">vit_stats</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;test_loss&#39;: 0.06418210905976593,
 &#39;test_acc&#39;: 0.984659090909091,
 &#39;number_of_parameters&#39;: 85800963,
 &#39;model_size (MB)&#39;: 327}
</pre></div>
</div>
</div>
</div>
<p>Nice! Looks like our ViT model achieves over 95% accuracy too.</p>
</section>
</section>
<section id="making-predictions-with-our-trained-models-and-timing-them">
<h2>5. Making predictions with our trained models and timing them<a class="headerlink" href="#making-predictions-with-our-trained-models-and-timing-them" title="Permalink to this heading">#</a></h2>
<p>We’ve got a couple of trained models, both performing pretty well.</p>
<p>Now how about we test them out doing what we’d like them to do?</p>
<p>As in, let’s see how they go making predictions (performing inference).</p>
<p>We know both of our models are performing at over 95% accuracy on the test dataset, but how fast are they?</p>
<p>Ideally, if we’re deploying our FoodVision Mini model to a mobile device so people can take photos of their food and identify it, we’d like the predictions to happen at real-time (~30 frames per second).</p>
<p>That’s why our second criteria is: a fast model.</p>
<p>To find out how long each of our models take to performance inference, let’s create a function called <code class="docutils literal notranslate"><span class="pre">pred_and_store()</span></code> to iterate over each of the test dataset images one by one and perform a prediction.</p>
<p>We’ll time each of the predictions as well as store the results in a common prediction format: a list of dictionaries (where each element in the list is a single prediction and each sinlge prediction is a dictionary).</p>
<blockquote>
<div><p><strong>Note:</strong> We time the predictions one by one rather than by batch because when our model is deployed, it will likely only be making a prediction on one image at a time. As in, someone takes a photo and our model predicts on that single image.</p>
</div></blockquote>
<p>Since we’d like to make predictions across all the images in the test set, let’s first get a list of all of the test image paths so we can iterate over them.</p>
<p>To do so, we’ll use Python’s <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#basic-use"><code class="docutils literal notranslate"><span class="pre">pathlib.Path(&quot;target_dir&quot;).glob(&quot;*/*.jpg&quot;))</span></code></a> to find all of the filepaths in a target directory with the extension <code class="docutils literal notranslate"><span class="pre">.jpg</span></code> (all of our test images).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># Get all test data paths</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Finding all filepaths ending with &#39;.jpg&#39; in directory: </span><span class="si">{</span><span class="n">test_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">test_data_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">test_dir</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*/*.jpg&quot;</span><span class="p">))</span>
<span class="n">test_data_paths</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] Finding all filepaths ending with &#39;.jpg&#39; in directory: data/pizza_steak_sushi_20_percent/test
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[PosixPath(&#39;data/pizza_steak_sushi_20_percent/test/steak/831681.jpg&#39;),
 PosixPath(&#39;data/pizza_steak_sushi_20_percent/test/steak/3100563.jpg&#39;),
 PosixPath(&#39;data/pizza_steak_sushi_20_percent/test/steak/2752603.jpg&#39;),
 PosixPath(&#39;data/pizza_steak_sushi_20_percent/test/steak/39461.jpg&#39;),
 PosixPath(&#39;data/pizza_steak_sushi_20_percent/test/steak/730464.jpg&#39;)]
</pre></div>
</div>
</div>
</div>
<section id="creating-a-function-to-make-predictions-across-the-test-dataset">
<h3>5.1 Creating a function to make predictions across the test dataset<a class="headerlink" href="#creating-a-function-to-make-predictions-across-the-test-dataset" title="Permalink to this heading">#</a></h3>
<p>Now we’ve got a list of our test image paths, let’s get to work on our <code class="docutils literal notranslate"><span class="pre">pred_and_store()</span></code> function:</p>
<ol class="arabic simple">
<li><p>Create a function that takes a list of paths, a trained PyTorch model, a series of transforms (to prepare images), a list of target class names and a target device.</p></li>
<li><p>Create an empty list to store prediction dictionaries (we want the function to return a list of dictionaries, one for each prediction).</p></li>
<li><p>Loop through the target input paths (steps 4-14 will happen inside the loop).</p></li>
<li><p>Create an empty dictionary for each iteration in the loop to store prediction values per sample.</p></li>
<li><p>Get the sample path and ground truth class name (we can do this by infering the class from the path).</p></li>
<li><p>Start the prediction timer using Python’s <a class="reference external" href="https://docs.python.org/3/library/timeit.html#timeit.default_timer"><code class="docutils literal notranslate"><span class="pre">timeit.default_timer()</span></code></a>.</p></li>
<li><p>Open the image using <a class="reference external" href="https://pillow.readthedocs.io/en/stable/reference/Image.html#functions"><code class="docutils literal notranslate"><span class="pre">PIL.Image.open(path)</span></code></a>.</p></li>
<li><p>Transform the image so it’s capable of being using with the target model as well as add a batch dimension and send the image to the target device.</p></li>
<li><p>Prepare the model for inference by sending it to the target device and turning on <code class="docutils literal notranslate"><span class="pre">eval()</span></code> mode.</p></li>
<li><p>Turn on <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.inference_mode.html"><code class="docutils literal notranslate"><span class="pre">torch.inference_mode()</span></code></a> and pass the target transformed image to the model and calculate the prediction probability using <code class="docutils literal notranslate"><span class="pre">torch.softmax()</span></code> and the target label using <code class="docutils literal notranslate"><span class="pre">torch.argmax()</span></code>.</p></li>
<li><p>Add the prediction probability and prediction class to the prediction dictionary created in step 4. Also make sure the prediction probability is on the CPU so it can be used with non-GPU libraries such as NumPy and pandas for later inspection.</p></li>
<li><p>End the prediction timer started in step 6 and add the time to the prediction dictionary created in step 4.</p></li>
<li><p>See if the predicted class matches the ground truth class from step 5 and add the result to the prediction dictionary created in step 4.</p></li>
<li><p>Append the updated prediction dictionary to the empty list of predictions created in step 2.</p></li>
<li><p>Return the list of prediction dictionaries.</p></li>
</ol>
<p>A bunch of steps, but nothing we can’t handle!</p>
<p>Let’s do it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span> 
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># 1. Create a function to return a list of dictionaries with sample, truth label, prediction, prediction probability and prediction time</span>
<span class="k">def</span> <span class="nf">pred_and_store</span><span class="p">(</span><span class="n">paths</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">],</span> 
                   <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                   <span class="n">transform</span><span class="p">:</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">transforms</span><span class="p">,</span> 
                   <span class="n">class_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> 
                   <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
    
    <span class="c1"># 2. Create an empty list to store prediction dictionaires</span>
    <span class="n">pred_list</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># 3. Loop through target paths</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
        
        <span class="c1"># 4. Create empty dictionary to store prediction information for each sample</span>
        <span class="n">pred_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># 5. Get the sample path and ground truth class name</span>
        <span class="n">pred_dict</span><span class="p">[</span><span class="s2">&quot;image_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">stem</span>
        <span class="n">pred_dict</span><span class="p">[</span><span class="s2">&quot;class_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">class_name</span>
        
        <span class="c1"># 6. Start the prediction timer</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        
        <span class="c1"># 7. Open image path</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        
        <span class="c1"># 8. Transform the image, add batch dimension and put image on target device</span>
        <span class="n">transformed_image</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> 
        
        <span class="c1"># 9. Prepare model for inference by sending it to target device and turning on eval() mode</span>
        <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        
        <span class="c1"># 10. Get prediction probability, predicition label and prediction class</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">inference_mode</span><span class="p">():</span>
            <span class="n">pred_logit</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">transformed_image</span><span class="p">)</span> <span class="c1"># perform inference on target sample </span>
            <span class="n">pred_prob</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">pred_logit</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># turn logits into prediction probabilities</span>
            <span class="n">pred_label</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pred_prob</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># turn prediction probabilities into prediction label</span>
            <span class="n">pred_class</span> <span class="o">=</span> <span class="n">class_names</span><span class="p">[</span><span class="n">pred_label</span><span class="o">.</span><span class="n">cpu</span><span class="p">()]</span> <span class="c1"># hardcode prediction class to be on CPU</span>

            <span class="c1"># 11. Make sure things in the dictionary are on CPU (required for inspecting predictions later on) </span>
            <span class="n">pred_dict</span><span class="p">[</span><span class="s2">&quot;pred_prob&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">pred_prob</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">pred_dict</span><span class="p">[</span><span class="s2">&quot;pred_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred_class</span>
            
            <span class="c1"># 12. End the timer and calculate time per pred</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
            <span class="n">pred_dict</span><span class="p">[</span><span class="s2">&quot;time_for_pred&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">end_time</span><span class="o">-</span><span class="n">start_time</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># 13. Does the pred match the true label?</span>
        <span class="n">pred_dict</span><span class="p">[</span><span class="s2">&quot;correct&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">class_name</span> <span class="o">==</span> <span class="n">pred_class</span>

        <span class="c1"># 14. Add the dictionary to the list of preds</span>
        <span class="n">pred_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred_dict</span><span class="p">)</span>
    
    <span class="c1"># 15. Return list of prediction dictionaries</span>
    <span class="k">return</span> <span class="n">pred_list</span>
</pre></div>
</div>
</div>
</div>
<p>Ho, ho!</p>
<p>What a good looking function!</p>
<p>And you know what, since our <code class="docutils literal notranslate"><span class="pre">pred_and_store()</span></code> is a pretty good utility function for making and storing predictions, it could be stored to <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/going_modular/going_modular/predictions.py"><code class="docutils literal notranslate"><span class="pre">going_modular.going_modular.predictions.py</span></code></a> for later use. That might be an extension you’d like to try, check out <a class="reference external" href="https://www.learnpytorch.io/05_pytorch_going_modular/">05. PyTorch Going Modular</a> for ideas.</p>
</section>
<section id="making-and-timing-predictions-with-effnetb2">
<h3>5.2 Making and timing predictions with EffNetB2<a class="headerlink" href="#making-and-timing-predictions-with-effnetb2" title="Permalink to this heading">#</a></h3>
<p>Time to test out our <code class="docutils literal notranslate"><span class="pre">pred_and_store()</span></code> function!</p>
<p>Let’s start by using it to make predictions across the test dataset with our EffNetB2 model, paying attention to two details:</p>
<ol class="arabic simple">
<li><p><strong>Device</strong> - We’ll hard code the <code class="docutils literal notranslate"><span class="pre">device</span></code> parameter to use <code class="docutils literal notranslate"><span class="pre">&quot;cpu&quot;</span></code> because when we deploy our model, we won’t always have access to a <code class="docutils literal notranslate"><span class="pre">&quot;cuda&quot;</span></code> (GPU) device.</p>
<ul class="simple">
<li><p>Making the predictions on CPU will be a good indicator of speed of inference too because generally predictions on CPU devices are slower than GPU devices.</p></li>
</ul>
</li>
<li><p><strong>Transforms</strong> - We’ll also be sure to set the <code class="docutils literal notranslate"><span class="pre">transform</span></code> parameter to <code class="docutils literal notranslate"><span class="pre">effnetb2_transforms</span></code> to make sure the images are opened and transformed in the same way our <code class="docutils literal notranslate"><span class="pre">effnetb2</span></code> model has been trained on.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make predictions across test dataset with EffNetB2</span>
<span class="n">effnetb2_test_pred_dicts</span> <span class="o">=</span> <span class="n">pred_and_store</span><span class="p">(</span><span class="n">paths</span><span class="o">=</span><span class="n">test_data_paths</span><span class="p">,</span>
                                          <span class="n">model</span><span class="o">=</span><span class="n">effnetb2</span><span class="p">,</span>
                                          <span class="n">transform</span><span class="o">=</span><span class="n">effnetb2_transforms</span><span class="p">,</span>
                                          <span class="n">class_names</span><span class="o">=</span><span class="n">class_names</span><span class="p">,</span>
                                          <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span> <span class="c1"># make predictions on CPU </span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "9b516a8ba5ce4603a25ae0b6d5f8573a", "version_major": 2, "version_minor": 0}</script></div>
</div>
<p>Nice! Look at those predictions fly!</p>
<p>Let’s inspect the first couple and see what they look like.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Inspect the first 2 prediction dictionaries</span>
<span class="n">effnetb2_test_pred_dicts</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[{&#39;image_path&#39;: PosixPath(&#39;data/pizza_steak_sushi_20_percent/test/steak/831681.jpg&#39;),
  &#39;class_name&#39;: &#39;steak&#39;,
  &#39;pred_prob&#39;: 0.9293,
  &#39;pred_class&#39;: &#39;steak&#39;,
  &#39;time_for_pred&#39;: 0.0494,
  &#39;correct&#39;: True},
 {&#39;image_path&#39;: PosixPath(&#39;data/pizza_steak_sushi_20_percent/test/steak/3100563.jpg&#39;),
  &#39;class_name&#39;: &#39;steak&#39;,
  &#39;pred_prob&#39;: 0.9534,
  &#39;pred_class&#39;: &#39;steak&#39;,
  &#39;time_for_pred&#39;: 0.0264,
  &#39;correct&#39;: True}]
</pre></div>
</div>
</div>
</div>
<p>Woohoo!</p>
<p>It looks like our <code class="docutils literal notranslate"><span class="pre">pred_and_store()</span></code> function worked nicely.</p>
<p>Thanks to our list of dictionaries data structure, we’ve got plenty of useful information we can further inspect.</p>
<p>To do so, let’s turn our list of dictionaries into a pandas DataFrame.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Turn the test_pred_dicts into a DataFrame</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="n">effnetb2_test_pred_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">effnetb2_test_pred_dicts</span><span class="p">)</span>
<span class="n">effnetb2_test_pred_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>image_path</th>
      <th>class_name</th>
      <th>pred_prob</th>
      <th>pred_class</th>
      <th>time_for_pred</th>
      <th>correct</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/8...</td>
      <td>steak</td>
      <td>0.9293</td>
      <td>steak</td>
      <td>0.0494</td>
      <td>True</td>
    </tr>
    <tr>
      <th>1</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/3...</td>
      <td>steak</td>
      <td>0.9534</td>
      <td>steak</td>
      <td>0.0264</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/2...</td>
      <td>steak</td>
      <td>0.7532</td>
      <td>steak</td>
      <td>0.0256</td>
      <td>True</td>
    </tr>
    <tr>
      <th>3</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/3...</td>
      <td>steak</td>
      <td>0.5935</td>
      <td>steak</td>
      <td>0.0263</td>
      <td>True</td>
    </tr>
    <tr>
      <th>4</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/7...</td>
      <td>steak</td>
      <td>0.8959</td>
      <td>steak</td>
      <td>0.0269</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Beautiful!</p>
<p>Look how easily those prediction dictionaries turn into a structured format we can perform analysis on.</p>
<p>Such as finding how many predictions our EffNetB2 model got wrong…</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check number of correct predictions</span>
<span class="n">effnetb2_test_pred_df</span><span class="o">.</span><span class="n">correct</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True     145
False      5
Name: correct, dtype: int64
</pre></div>
</div>
</div>
</div>
<p>Five wrong predictions out of 150 total, not bad!</p>
<p>And how about the average prediction time?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find the average time per prediction </span>
<span class="n">effnetb2_average_time_per_pred</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">effnetb2_test_pred_df</span><span class="o">.</span><span class="n">time_for_pred</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;EffNetB2 average time per prediction: </span><span class="si">{</span><span class="n">effnetb2_average_time_per_pred</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>EffNetB2 average time per prediction: 0.0269 seconds
</pre></div>
</div>
</div>
</div>
<p>Hmm, how does that average prediction time live up to our criteria of our model performing at real-time (~30FPS or 0.03 seconds per prediction)?</p>
<blockquote>
<div><p><strong>Note:</strong> Prediction times will be different across different hardware types (e.g. a local Intel i9 vs Google Colab CPU). The better and faster the hardware, generally, the faster the prediction. For example, on my local deep learning PC with an Intel i9 chip, my average prediction time with EffNetB2 is around 0.031 seconds (just under real-time). However, on Google Colab (I’m not sure what CPU hardware Colab uses but it looks like it might be an <a class="reference external" href="https://stackoverflow.com/questions/47805170/whats-the-hardware-spec-for-google-colaboratory">Intel® Xeon®</a>), my average prediction time with EffNetB2 is about 0.1396 seconds (3-4x slower).</p>
</div></blockquote>
<p>Let’s add our EffNetB2 average time per prediction to our <code class="docutils literal notranslate"><span class="pre">effnetb2_stats</span></code> dictionary.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add EffNetB2 average prediction time to stats dictionary </span>
<span class="n">effnetb2_stats</span><span class="p">[</span><span class="s2">&quot;time_per_pred_cpu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">effnetb2_average_time_per_pred</span>
<span class="n">effnetb2_stats</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;test_loss&#39;: 0.28128674924373626,
 &#39;test_acc&#39;: 0.96875,
 &#39;number_of_parameters&#39;: 7705221,
 &#39;model_size (MB)&#39;: 29,
 &#39;time_per_pred_cpu&#39;: 0.0269}
</pre></div>
</div>
</div>
</div>
</section>
<section id="making-and-timing-predictions-with-vit">
<h3>5.3 Making and timing predictions with ViT<a class="headerlink" href="#making-and-timing-predictions-with-vit" title="Permalink to this heading">#</a></h3>
<p>We’ve made predictions with our EffNetB2 model, now let’s do the same for our ViT model.</p>
<p>To do so, we can use the <code class="docutils literal notranslate"><span class="pre">pred_and_store()</span></code> function we created above except this time we’ll pass in our <code class="docutils literal notranslate"><span class="pre">vit</span></code> model as well as the <code class="docutils literal notranslate"><span class="pre">vit_transforms</span></code>.</p>
<p>And we’ll keep the predictions on the CPU via <code class="docutils literal notranslate"><span class="pre">device=&quot;cpu&quot;</span></code> (a natural extension here would be to test the prediction times on CPU and on GPU).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make list of prediction dictionaries with ViT feature extractor model on test images</span>
<span class="n">vit_test_pred_dicts</span> <span class="o">=</span> <span class="n">pred_and_store</span><span class="p">(</span><span class="n">paths</span><span class="o">=</span><span class="n">test_data_paths</span><span class="p">,</span>
                                     <span class="n">model</span><span class="o">=</span><span class="n">vit</span><span class="p">,</span>
                                     <span class="n">transform</span><span class="o">=</span><span class="n">vit_transforms</span><span class="p">,</span>
                                     <span class="n">class_names</span><span class="o">=</span><span class="n">class_names</span><span class="p">,</span>
                                     <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "2c6e2d8224d84f1c9158c60fe3f7fd9f", "version_major": 2, "version_minor": 0}</script></div>
</div>
<p>Predictions made!</p>
<p>Now let’s check out the first couple.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the first couple of ViT predictions on the test dataset</span>
<span class="n">vit_test_pred_dicts</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[{&#39;image_path&#39;: PosixPath(&#39;data/pizza_steak_sushi_20_percent/test/steak/831681.jpg&#39;),
  &#39;class_name&#39;: &#39;steak&#39;,
  &#39;pred_prob&#39;: 0.9933,
  &#39;pred_class&#39;: &#39;steak&#39;,
  &#39;time_for_pred&#39;: 0.1313,
  &#39;correct&#39;: True},
 {&#39;image_path&#39;: PosixPath(&#39;data/pizza_steak_sushi_20_percent/test/steak/3100563.jpg&#39;),
  &#39;class_name&#39;: &#39;steak&#39;,
  &#39;pred_prob&#39;: 0.9893,
  &#39;pred_class&#39;: &#39;steak&#39;,
  &#39;time_for_pred&#39;: 0.0638,
  &#39;correct&#39;: True}]
</pre></div>
</div>
</div>
</div>
<p>Wonderful!</p>
<p>And just like before, since our ViT model’s predictions are in the form of a list of dictionaries, we can easily turn them into a pandas DataFrame for further inspection.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Turn vit_test_pred_dicts into a DataFrame</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="n">vit_test_pred_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">vit_test_pred_dicts</span><span class="p">)</span>
<span class="n">vit_test_pred_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>image_path</th>
      <th>class_name</th>
      <th>pred_prob</th>
      <th>pred_class</th>
      <th>time_for_pred</th>
      <th>correct</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/8...</td>
      <td>steak</td>
      <td>0.9933</td>
      <td>steak</td>
      <td>0.1313</td>
      <td>True</td>
    </tr>
    <tr>
      <th>1</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/3...</td>
      <td>steak</td>
      <td>0.9893</td>
      <td>steak</td>
      <td>0.0638</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/2...</td>
      <td>steak</td>
      <td>0.9971</td>
      <td>steak</td>
      <td>0.0627</td>
      <td>True</td>
    </tr>
    <tr>
      <th>3</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/3...</td>
      <td>steak</td>
      <td>0.7685</td>
      <td>steak</td>
      <td>0.0632</td>
      <td>True</td>
    </tr>
    <tr>
      <th>4</th>
      <td>data/pizza_steak_sushi_20_percent/test/steak/7...</td>
      <td>steak</td>
      <td>0.9499</td>
      <td>steak</td>
      <td>0.0641</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>How many predictions did our ViT model get correct?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Count the number of correct predictions</span>
<span class="n">vit_test_pred_df</span><span class="o">.</span><span class="n">correct</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True     148
False      2
Name: correct, dtype: int64
</pre></div>
</div>
</div>
</div>
<p>Woah!</p>
<p>Our ViT model did a little better than our EffNetB2 model in terms of correct predictions, only two samples wrong across the whole test dataset.</p>
<p>As an extension you might want to visualize the ViT model’s wrong predictions and see if there’s any reason why it might’ve got them wrong.</p>
<p>How about we calculate how long the ViT model took per prediction?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate average time per prediction for ViT model</span>
<span class="n">vit_average_time_per_pred</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">vit_test_pred_df</span><span class="o">.</span><span class="n">time_for_pred</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ViT average time per prediction: </span><span class="si">{</span><span class="n">vit_average_time_per_pred</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ViT average time per prediction: 0.0641 seconds
</pre></div>
</div>
</div>
</div>
<p>Well, that looks a little slower than our EffNetB2 model’s average time per prediction but how does it look in terms of our second criteria: speed?</p>
<p>For now, let’s add the value to our <code class="docutils literal notranslate"><span class="pre">vit_stats</span></code> dictionary so we can compare it to our EffNetB2 model’s stats.</p>
<blockquote>
<div><p><strong>Note:</strong> The average time per prediction values will be highly dependent on the hardware you make them on. For example, for the ViT model, my average time per prediction (on the CPU) was 0.0693-0.0777 seconds on my local deep learning PC with an Intel i9 CPU. Where as on Google Colab, my average time per prediction with the ViT model was 0.6766-0.7113 seconds.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add average prediction time for ViT model on CPU</span>
<span class="n">vit_stats</span><span class="p">[</span><span class="s2">&quot;time_per_pred_cpu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vit_average_time_per_pred</span>
<span class="n">vit_stats</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;test_loss&#39;: 0.06418210905976593,
 &#39;test_acc&#39;: 0.984659090909091,
 &#39;number_of_parameters&#39;: 85800963,
 &#39;model_size (MB)&#39;: 327,
 &#39;time_per_pred_cpu&#39;: 0.0641}
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="comparing-model-results-prediction-times-and-size">
<h2>6. Comparing model results, prediction times and size<a class="headerlink" href="#comparing-model-results-prediction-times-and-size" title="Permalink to this heading">#</a></h2>
<p>Our two best model contenders have been trained and evaluated.</p>
<p>Now let’s put them head to head and compare across their different statistics.</p>
<p>To do so, let’s turn our <code class="docutils literal notranslate"><span class="pre">effnetb2_stats</span></code> and <code class="docutils literal notranslate"><span class="pre">vit_stats</span></code> dictionaries into a pandas DataFrame.</p>
<p>We’ll add a column to view the model names as well as the convert the test accuracy to a whole percentage rather than decimal.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Turn stat dictionaries into DataFrame</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">effnetb2_stats</span><span class="p">,</span> <span class="n">vit_stats</span><span class="p">])</span>

<span class="c1"># Add column for model names</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;EffNetB2&quot;</span><span class="p">,</span> <span class="s2">&quot;ViT&quot;</span><span class="p">]</span>

<span class="c1"># Convert accuracy to percentages</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;test_acc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;test_acc&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">df</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>test_loss</th>
      <th>test_acc</th>
      <th>number_of_parameters</th>
      <th>model_size (MB)</th>
      <th>time_per_pred_cpu</th>
      <th>model</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.281287</td>
      <td>96.88</td>
      <td>7705221</td>
      <td>29</td>
      <td>0.0269</td>
      <td>EffNetB2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.064182</td>
      <td>98.47</td>
      <td>85800963</td>
      <td>327</td>
      <td>0.0641</td>
      <td>ViT</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Wonderful!</p>
<p>It seems our models are quite close in terms of overall test accuracy but how do they look across the other fields?</p>
<p>One way to find out would be to divide the ViT model statistics by the EffNetB2 model statistics to find out the different ratios between the models.</p>
<p>Let’s create another DataFrame to do so.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compare ViT to EffNetB2 across different characteristics</span>
<span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;model&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;ViT&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;model&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;EffNetB2&quot;</span><span class="p">]),</span> <span class="c1"># divide ViT statistics by EffNetB2 statistics</span>
             <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ViT to EffNetB2 ratios&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>test_loss</th>
      <th>test_acc</th>
      <th>number_of_parameters</th>
      <th>model_size (MB)</th>
      <th>time_per_pred_cpu</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>ViT to EffNetB2 ratios</th>
      <td>0.228173</td>
      <td>1.016412</td>
      <td>11.135432</td>
      <td>11.275862</td>
      <td>2.3829</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>It seems our ViT model outperforms the EffNetB2 model across the performance metrics (test loss, where lower is better and test accuracy, where higher is better) but at the expense of having:</p>
<ul class="simple">
<li><p>11x+ the number of parameters.</p></li>
<li><p>11x+ the model size.</p></li>
<li><p>2.5x+ the prediction time per image.</p></li>
</ul>
<p>Are these tradeoffs worth it?</p>
<p>Perhaps if we had unlimited compute power but for our use case of deploying the FoodVision Mini model to a smaller device (e.g. a mobile phone), we’d likely start out with the EffNetB2 model for faster predictions at a slightly reduced performance but dramatically smaller</p>
<section id="visualizing-the-speed-vs-performance-tradeoff">
<h3>6.1 Visualizing the speed vs. performance tradeoff<a class="headerlink" href="#visualizing-the-speed-vs-performance-tradeoff" title="Permalink to this heading">#</a></h3>
<p>We’ve seen that our ViT model outperforms our EffNetB2 model in terms of performance metrics such as test loss and test accuracy.</p>
<p>However, our EffNetB2 model makes performs predictions faster and has a much small model size.</p>
<blockquote>
<div><p><strong>Note:</strong> Performance or inference time is also often referred to as “latency”.</p>
</div></blockquote>
<p>How about we make this fact visual?</p>
<p>We can do so by creating a plot with matplotlib:</p>
<ol class="arabic simple">
<li><p>Create a scatter plot from the comparison DataFrame to compare EffNetB2 and ViT <code class="docutils literal notranslate"><span class="pre">time_per_pred_cpu</span></code> and <code class="docutils literal notranslate"><span class="pre">test_acc</span></code> values.</p></li>
<li><p>Add titles and labels respective of the data and customize the fontsize for aesthetics.</p></li>
<li><p>Annotate the samples on the scatter plot from step 1 with their appropriate labels (the model names).</p></li>
<li><p>Create a legend based on the model sizes (<code class="docutils literal notranslate"><span class="pre">model_size</span> <span class="pre">(MB)</span></code>).</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 1. Create a plot from model comparison DataFrame</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> 
                     <span class="n">x</span><span class="o">=</span><span class="s2">&quot;time_per_pred_cpu&quot;</span><span class="p">,</span> 
                     <span class="n">y</span><span class="o">=</span><span class="s2">&quot;test_acc&quot;</span><span class="p">,</span> 
                     <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="s2">&quot;orange&quot;</span><span class="p">],</span> <span class="c1"># what colours to use?</span>
                     <span class="n">s</span><span class="o">=</span><span class="s2">&quot;model_size (MB)&quot;</span><span class="p">)</span> <span class="c1"># size the dots by the model sizes</span>

<span class="c1"># 2. Add titles, labels and customize fontsize for aesthetics</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;FoodVision Mini Inference Speed vs Performance&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Prediction time per image (seconds)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Test accuracy (%)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># 3. Annotate with model names</span>
<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">],</span> <span class="c1"># note: depending on your version of Matplotlib, you may need to use &quot;s=...&quot; or &quot;text=...&quot;, see: https://github.com/faustomorales/keras-ocr/issues/183#issuecomment-977733270 </span>
                <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;time_per_pred_cpu&quot;</span><span class="p">]</span><span class="o">+</span><span class="mf">0.0006</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;test_acc&quot;</span><span class="p">]</span><span class="o">+</span><span class="mf">0.03</span><span class="p">),</span>
                <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># 4. Create a legend based on model sizes</span>
<span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">scatter</span><span class="o">.</span><span class="n">legend_elements</span><span class="p">(</span><span class="n">prop</span><span class="o">=</span><span class="s2">&quot;sizes&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">model_size_legend</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="p">,</span> 
                              <span class="n">labels</span><span class="p">,</span> 
                              <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">,</span> 
                              <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Model size (MB)&quot;</span><span class="p">,</span>
                              <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Save the figure</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;images/09-foodvision-mini-inference-speed-vs-performance.jpg&quot;</span><span class="p">)</span>

<span class="c1"># Show the figure</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/0f564e8b6081feb2df59dddc53cae0e81c6d6557c8b75ba75270ecf992e05005.png" src="../../_images/0f564e8b6081feb2df59dddc53cae0e81c6d6557c8b75ba75270ecf992e05005.png" />
</div>
</div>
<p>Woah!</p>
<p>The plot really visualizes the <strong>speed vs. performance tradeoff</strong>, in other words, when you have a larger, better performing deep model (like our ViT model), it <em>generally</em> takes longer to perform inference (higher latency).</p>
<p>There are exceptions to the rule and new research is being published all the time to help make larger models perform faster.</p>
<p>And it can be tempting to just deploy the <em>best</em> performing model but it’s also good to take into considersation where the model is going to be performing.</p>
<p>In our case, the differences between our model’s performance levels (on the test loss and test accuracy) aren’t too extreme.</p>
<p>But since we’d like to put an emphasis on speed to begin with, we’re going to stick with deploying EffNetB2 since it’s faster and has a much smaller footprint.</p>
<blockquote>
<div><p><strong>Note:</strong> Prediction times will be different across different hardware types (e.g. Intel i9 vs Google Colab CPU vs GPU) so it’s important to think about and test where your model is going to end up. Asking questions like “where is the model going to be run?” or “what is the ideal scenario for running the model?” and then running experiments to try and provide answers on your way to deployment is very helpful.</p>
</div></blockquote>
</section>
</section>
<section id="bringing-foodvision-mini-to-life-by-creating-a-gradio-demo">
<h2>7. Bringing FoodVision Mini to life by creating a Gradio demo<a class="headerlink" href="#bringing-foodvision-mini-to-life-by-creating-a-gradio-demo" title="Permalink to this heading">#</a></h2>
<p>We’ve decided we’d like to deploy the EffNetB2 model (to begin with, this could always be changed later).</p>
<p>So how can we do that?</p>
<p>There are several ways to deploy a machine learning model each with specific use cases (as discussed above).</p>
<p>We’re going to be focused on perhaps the quickest and certainly one of the most fun ways to get a model deployed to the internet.</p>
<p>And that’s by using <a class="reference external" href="https://gradio.app/">Gradio</a>.</p>
<p>What’s Gradio?</p>
<p>The homepage describes it beautifully:</p>
<blockquote>
<div><p>Gradio is the fastest way to demo your machine learning model with a friendly web interface so that anyone can use it, anywhere!</p>
</div></blockquote>
<p>Why create a demo of your models?</p>
<p>Because metrics on the test set look nice but you never really know how you’re model performs until you use it in the wild.</p>
<p>So let’s get deploying!</p>
<p>We’ll start by importing Gradio with the common alias <code class="docutils literal notranslate"><span class="pre">gr</span></code> and if it’s not present, we’ll install it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import/install Gradio </span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">gradio</span> <span class="k">as</span> <span class="nn">gr</span>
<span class="k">except</span><span class="p">:</span> 
    <span class="o">!</span>pip<span class="w"> </span>-q<span class="w"> </span>install<span class="w"> </span>gradio
    <span class="kn">import</span> <span class="nn">gradio</span> <span class="k">as</span> <span class="nn">gr</span>
    
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gradio version: </span><span class="si">{</span><span class="n">gr</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Gradio version: 3.1.4
</pre></div>
</div>
</div>
</div>
<p>Gradio ready!</p>
<p>Let’s turn FoodVision Mini into a demo application.</p>
<section id="gradio-overview">
<h3>7.1 Gradio overview<a class="headerlink" href="#gradio-overview" title="Permalink to this heading">#</a></h3>
<p>The overall premise of Gradio is very similar to what we’ve been repeating throughout the course.</p>
<p>What are our <strong>inputs</strong> and <strong>outputs</strong>?</p>
<p>And how should we get there?</p>
<p>Well that’s what our machine learning model does.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">-&gt;</span> <span class="n">ML</span> <span class="n">model</span> <span class="o">-&gt;</span> <span class="n">outputs</span>
</pre></div>
</div>
<p>In our case, for FoodVision Mini, our inputs are images of food, our ML model is EffNetB2 and our outputs are classes of food (pizza, steak or sushi).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">images</span> <span class="n">of</span> <span class="n">food</span> <span class="o">-&gt;</span> <span class="n">EffNetB2</span> <span class="o">-&gt;</span> <span class="n">outputs</span>
</pre></div>
</div>
<p>Though the concepts of inputs and outputs can be bridged to almost any other kind of ML problem.</p>
<p>Your inputs and outputs might be any combination of the following:</p>
<ul class="simple">
<li><p>Images</p></li>
<li><p>Text</p></li>
<li><p>Video</p></li>
<li><p>Tabular data</p></li>
<li><p>Audio</p></li>
<li><p>Numbers</p></li>
<li><p>&amp; more</p></li>
</ul>
<p>And the ML model you build will depend on your inputs and outputs.</p>
<p>Gradio emulates this paradigm by creating an interface (<a class="reference external" href="https://gradio.app/docs/#interface-header"><code class="docutils literal notranslate"><span class="pre">gradio.Interface()</span></code></a>) to from inputs to outputs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gradio</span><span class="o">.</span><span class="n">Interface</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
</pre></div>
</div>
<p>Where, <code class="docutils literal notranslate"><span class="pre">fn</span></code> is a Python function to map the <code class="docutils literal notranslate"><span class="pre">inputs</span></code> to the <code class="docutils literal notranslate"><span class="pre">outputs</span></code>.</p>
<img alt="gradio workflow of inputs flowing into some kind of model or function and then producing outputs" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-gradio-workflow.png" />
<p><em>Gradio provides a very helpful <code class="docutils literal notranslate"><span class="pre">Interface</span></code> class to easily create an inputs -&gt; model/function -&gt; outputs workflow where the inputs and outputs could be almost anything you want. For example, you might input Tweets (text) to see if they’re about machine learning or not or <a class="reference external" href="https://huggingface.co/blog/stable_diffusion">input a text prompt to generate images</a>.</em></p>
<blockquote>
<div><p><strong>Note:</strong> Gradio has a vast number of possible <code class="docutils literal notranslate"><span class="pre">inputs</span></code> and <code class="docutils literal notranslate"><span class="pre">outputs</span></code> options known as “Components” from images to text to numbers to audio to videos and more. You can see all of these in the <a class="reference external" href="https://gradio.app/docs/#components">Gradio Components documentation</a>.</p>
</div></blockquote>
</section>
<section id="creating-a-function-to-map-our-inputs-and-outputs">
<h3>7.2 Creating a function to map our inputs and outputs<a class="headerlink" href="#creating-a-function-to-map-our-inputs-and-outputs" title="Permalink to this heading">#</a></h3>
<p>To create our FoodVision Mini demo with Gradio, we’ll need a function to map our inputs to our outputs.</p>
<p>We created a function earlier called <code class="docutils literal notranslate"><span class="pre">pred_and_store()</span></code> to make predictions with a given model across a list of target files and store them in a list of dictionaries.</p>
<p>How about we create a similar function but this time focusing on a making a prediction on a single image with our EffNetB2 model?</p>
<p>More specifically, we want a function that takes an image as input, preprocesses (transforms) it, makes a prediction with EffNetB2 and then returns the prediction (pred or pred label for short) as well as the prediction probability (pred prob).</p>
<p>And while we’re here, let’s return the time it took to do so too:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">input</span><span class="p">:</span> <span class="n">image</span> <span class="o">-&gt;</span> <span class="n">transform</span> <span class="o">-&gt;</span> <span class="n">predict</span> <span class="k">with</span> <span class="n">EffNetB2</span> <span class="o">-&gt;</span> <span class="n">output</span><span class="p">:</span> <span class="n">pred</span><span class="p">,</span> <span class="n">pred</span> <span class="n">prob</span><span class="p">,</span> <span class="n">time</span> <span class="n">taken</span>
</pre></div>
</div>
<p>This will be our <code class="docutils literal notranslate"><span class="pre">fn</span></code> parameter for our Gradio interface.</p>
<p>First, let’s make sure our EffNetB2 model is on the CPU (since we’re sticking with CPU-only predictions, however you could change this if you have access to a GPU).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Put EffNetB2 on CPU</span>
<span class="n">effnetb2</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span> 

<span class="c1"># Check the device</span>
<span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">effnetb2</span><span class="o">.</span><span class="n">parameters</span><span class="p">()))</span><span class="o">.</span><span class="n">device</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>device(type=&#39;cpu&#39;)
</pre></div>
</div>
</div>
</div>
<p>And now let’s create a function called <code class="docutils literal notranslate"><span class="pre">predict()</span></code> to replicate the workflow above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span>

<span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transforms and performs a prediction on img and returns prediction and time taken.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Start the timer</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    
    <span class="c1"># Transform the target image and add a batch dimension</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">effnetb2_transforms</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Put model into evaluation mode and turn on inference mode</span>
    <span class="n">effnetb2</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">inference_mode</span><span class="p">():</span>
        <span class="c1"># Pass the transformed image through the model and turn the prediction logits into prediction probabilities</span>
        <span class="n">pred_probs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">effnetb2</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Create a prediction label and prediction probability dictionary for each prediction class (this is the required format for Gradio&#39;s output parameter)</span>
    <span class="n">pred_labels_and_probs</span> <span class="o">=</span> <span class="p">{</span><span class="n">class_names</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="nb">float</span><span class="p">(</span><span class="n">pred_probs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">class_names</span><span class="p">))}</span>
    
    <span class="c1"># Calculate the prediction time</span>
    <span class="n">pred_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    
    <span class="c1"># Return the prediction dictionary and prediction time </span>
    <span class="k">return</span> <span class="n">pred_labels_and_probs</span><span class="p">,</span> <span class="n">pred_time</span>
</pre></div>
</div>
</div>
</div>
<p>Beautiful!</p>
<p>Now let’s see our function in action by performing a prediction on a random image from the test dataset.</p>
<p>We’ll start by getting a list of all the image paths from the test directory and then randomly selecting one.</p>
<p>Then we’ll open the randomly selected image with <a class="reference external" href="https://pillow.readthedocs.io/en/stable/reference/Image.html#functions"><code class="docutils literal notranslate"><span class="pre">PIL.Image.open()</span></code></a>.</p>
<p>Finally, we’ll pass the image to our <code class="docutils literal notranslate"><span class="pre">predict()</span></code> function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="c1"># Get a list of all test image filepaths</span>
<span class="n">test_data_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">test_dir</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*/*.jpg&quot;</span><span class="p">))</span>

<span class="c1"># Randomly select a test image path</span>
<span class="n">random_image_path</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">test_data_paths</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Open the target image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">random_image_path</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Predicting on image at path: </span><span class="si">{</span><span class="n">random_image_path</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Predict on the target image and print out the outputs</span>
<span class="n">pred_dict</span><span class="p">,</span> <span class="n">pred_time</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Prediction label and probability dictionary: </span><span class="se">\n</span><span class="si">{</span><span class="n">pred_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Prediction time: </span><span class="si">{</span><span class="n">pred_time</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] Predicting on image at path: data/pizza_steak_sushi_20_percent/test/pizza/3770514.jpg

Prediction label and probability dictionary: 
{&#39;pizza&#39;: 0.9785208702087402, &#39;steak&#39;: 0.01169557310640812, &#39;sushi&#39;: 0.009783552028238773}
Prediction time: 0.027 seconds
</pre></div>
</div>
</div>
</div>
<p>Nice!</p>
<p>Running the cell above a few times we can see different prediction probabilities for each label from our EffNetB2 model as well as the time it took per prediction.</p>
</section>
<section id="creating-a-list-of-example-images">
<h3>7.3 Creating a list of example images<a class="headerlink" href="#creating-a-list-of-example-images" title="Permalink to this heading">#</a></h3>
<p>Our <code class="docutils literal notranslate"><span class="pre">predict()</span></code> function enables us to go from inputs -&gt; transform -&gt; ML model -&gt; outputs.</p>
<p>Which is exactly what we need for our Graido demo.</p>
<p>But before we create the demo, let’s create one more thing: a list of examples.</p>
<p>Gradio’s <a class="reference external" href="https://gradio.app/docs/#interface"><code class="docutils literal notranslate"><span class="pre">Interface</span></code></a> class takes a list of <code class="docutils literal notranslate"><span class="pre">examples</span></code> of as an optional parameter (<code class="docutils literal notranslate"><span class="pre">gradio.Interface(examples=List[Any])</span></code>).</p>
<p>And the format for the <code class="docutils literal notranslate"><span class="pre">examples</span></code> parameter is a list of lists.</p>
<p>So let’s create a list of lists containing random filepaths to our test images.</p>
<p>Three examples should be enough.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a list of example inputs to our Gradio demo</span>
<span class="n">example_list</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="n">filepath</span><span class="p">)]</span> <span class="k">for</span> <span class="n">filepath</span> <span class="ow">in</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">test_data_paths</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">example_list</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[&#39;data/pizza_steak_sushi_20_percent/test/sushi/804460.jpg&#39;],
 [&#39;data/pizza_steak_sushi_20_percent/test/steak/746921.jpg&#39;],
 [&#39;data/pizza_steak_sushi_20_percent/test/steak/2117351.jpg&#39;]]
</pre></div>
</div>
</div>
</div>
<p>Perfect!</p>
<p>Our Gradio demo will showcase these as example inputs to our demo so people can try it out and see what it does without uploading any of their own data.</p>
</section>
<section id="building-a-gradio-interface">
<h3>7.4 Building a Gradio interface<a class="headerlink" href="#building-a-gradio-interface" title="Permalink to this heading">#</a></h3>
<p>Time to put everything together and bring our FoodVision Mini demo to life!</p>
<p>Let’s create a Gradio interface to replicate the workflow:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">input</span><span class="p">:</span> <span class="n">image</span> <span class="o">-&gt;</span> <span class="n">transform</span> <span class="o">-&gt;</span> <span class="n">predict</span> <span class="k">with</span> <span class="n">EffNetB2</span> <span class="o">-&gt;</span> <span class="n">output</span><span class="p">:</span> <span class="n">pred</span><span class="p">,</span> <span class="n">pred</span> <span class="n">prob</span><span class="p">,</span> <span class="n">time</span> <span class="n">taken</span>
</pre></div>
</div>
<p>We can do with the <a class="reference external" href="https://gradio.app/docs/#interface"><code class="docutils literal notranslate"><span class="pre">gradio.Interface()</span></code></a> class with the following parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fn</span></code> - a Python function to map <code class="docutils literal notranslate"><span class="pre">inputs</span></code> to <code class="docutils literal notranslate"><span class="pre">outputs</span></code>, in our case, we’ll use our <code class="docutils literal notranslate"><span class="pre">predict()</span></code> function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputs</span></code> - the input to our interface, such as an image using <a class="reference external" href="https://gradio.app/docs/#image"><code class="docutils literal notranslate"><span class="pre">gradio.Image()</span></code></a> or <code class="docutils literal notranslate"><span class="pre">&quot;image&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">outputs</span></code> - the output of our interface once the <code class="docutils literal notranslate"><span class="pre">inputs</span></code> have gone through the <code class="docutils literal notranslate"><span class="pre">fn</span></code>, such as a label using <a class="reference external" href="https://gradio.app/docs/#label"><code class="docutils literal notranslate"><span class="pre">gradio.Label()</span></code></a> (for our model’s predicted labels) or number using <a class="reference external" href="https://gradio.app/docs/#number"><code class="docutils literal notranslate"><span class="pre">gradio.Number()</span></code></a> (for our model’s prediction time).</p>
<ul>
<li><p><strong>Note:</strong> Gradio comes with many in-built <code class="docutils literal notranslate"><span class="pre">inputs</span></code> and <code class="docutils literal notranslate"><span class="pre">outputs</span></code> options known as <a class="reference external" href="https://gradio.app/docs/#components">“Components”</a>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">examples</span></code> - a list of examples to showcase for the demo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">title</span></code> - a string title of the demo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">description</span></code> - a string description of the demo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">article</span></code> - a reference note at the bottom of the demo.</p></li>
</ul>
<p>Once we’ve created our demo instance of <code class="docutils literal notranslate"><span class="pre">gr.Interface()</span></code>, we can bring it to life using <a class="reference external" href="https://gradio.app/docs/#launch-header"><code class="docutils literal notranslate"><span class="pre">gradio.Interface().launch()</span></code></a> or <code class="docutils literal notranslate"><span class="pre">demo.launch()</span></code> command.</p>
<p>Easy!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gradio</span> <span class="k">as</span> <span class="nn">gr</span>

<span class="c1"># Create title, description and article strings</span>
<span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;FoodVision Mini 🍕🥩🍣&quot;</span>
<span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;An EfficientNetB2 feature extractor computer vision model to classify images of food as pizza, steak or sushi.&quot;</span>
<span class="n">article</span> <span class="o">=</span> <span class="s2">&quot;Created at [09. PyTorch Model Deployment](https://www.learnpytorch.io/09_pytorch_model_deployment/).&quot;</span>

<span class="c1"># Create the Gradio demo</span>
<span class="n">demo</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">Interface</span><span class="p">(</span><span class="n">fn</span><span class="o">=</span><span class="n">predict</span><span class="p">,</span> <span class="c1"># mapping function from input to output</span>
                    <span class="n">inputs</span><span class="o">=</span><span class="n">gr</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;pil&quot;</span><span class="p">),</span> <span class="c1"># what are the inputs?</span>
                    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">gr</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="n">num_top_classes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Predictions&quot;</span><span class="p">),</span> <span class="c1"># what are the outputs?</span>
                             <span class="n">gr</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Prediction time (s)&quot;</span><span class="p">)],</span> <span class="c1"># our fn has two outputs, therefore we have two outputs</span>
                    <span class="n">examples</span><span class="o">=</span><span class="n">example_list</span><span class="p">,</span> 
                    <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                    <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
                    <span class="n">article</span><span class="o">=</span><span class="n">article</span><span class="p">)</span>

<span class="c1"># Launch the demo!</span>
<span class="n">demo</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># print errors locally?</span>
            <span class="n">share</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># generate a publically shareable URL?</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running on local URL:  http://127.0.0.1:7860/
Running on public URL: https://27541.gradio.app

This share link expires in 72 hours. For free permanent hosting, check out Spaces: https://huggingface.co/spaces
</pre></div>
</div>
<div class="output text_html"><div><iframe src="https://27541.gradio.app" width="900" height="500" allow="autoplay; camera; microphone;" frameborder="0" allowfullscreen></iframe></div></div><div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&lt;gradio.routes.App at 0x7f122dd0f0d0&gt;,
 &#39;http://127.0.0.1:7860/&#39;,
 &#39;https://27541.gradio.app&#39;)
</pre></div>
</div>
</div>
</div>
<img alt="Gradio demo running in Google Colab and on the web" src="https://github.com/thangckt/pytorch-deep-learning/raw/main/images/09-gradio-running-in-google-colab-and-in-browser.gif" />
<p><em>FoodVision Mini Gradio demo running in Google Colab and in the browser (the link when running from Google Colab only lasts for 72 hours). You can see the <a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_mini">permanent live demo on Hugging Face Spaces</a>.</em></p>
<p>Woohoo!!! What an epic demo!!!</p>
<p>FoodVision Mini has officially come to life in an interface someone could use and try out.</p>
<p>If you set the parameter <code class="docutils literal notranslate"><span class="pre">share=True</span></code> in the <code class="docutils literal notranslate"><span class="pre">launch()</span></code> method, Gradio also provides you with a shareable link such as <code class="docutils literal notranslate"><span class="pre">https://123XYZ.gradio.app</span></code> (this link is an example only and likely expired) which is valid for 72-hours.</p>
<p>The link provides a proxy back to the Gradio interface you launched.</p>
<p>For more permanent hosting, you can upload your Gradio app to <a class="reference external" href="https://huggingface.co/spaces">Hugging Face Spaces</a> or anywhere that runs Python code.</p>
</section>
</section>
<section id="turning-our-foodvision-mini-gradio-demo-into-a-deployable-app">
<h2>8. Turning our FoodVision Mini Gradio Demo into a deployable app<a class="headerlink" href="#turning-our-foodvision-mini-gradio-demo-into-a-deployable-app" title="Permalink to this heading">#</a></h2>
<p>We’ve seen our FoodVision Mini model come to life through a Gradio demo.</p>
<p>But what if we wanted to share it with our friends?</p>
<p>Well, we could use the provided Gradio link, however, the shared link only lasts for 72-hours.</p>
<p>To make our FoodVision Mini demo more permanent, we can package it into an app and upload it to <a class="reference external" href="https://huggingface.co/spaces/launch">Hugging Face Spaces</a>.</p>
<section id="what-is-hugging-face-spaces">
<h3>8.1 What is Hugging Face Spaces?<a class="headerlink" href="#what-is-hugging-face-spaces" title="Permalink to this heading">#</a></h3>
<p>Hugging Face Spaces is a resource that allows you to host and share machine learning apps.</p>
<p>Building a demo is one of the best ways to showcase and test what you’ve done.</p>
<p>And Spaces allows you to do just that.</p>
<p>You can think of Hugging Face as the GitHub of machine learning.</p>
<p>If having a good GitHub portfolio showcases your coding abilities, having a good Hugging Face portfolio can showcase your machine learning abilities.</p>
<blockquote>
<div><p><strong>Note:</strong> There are many other places we could upload and host our Gradio app such as, Google Cloud, AWS (Amazon Web Services) or other cloud vendors, however, we’re going to use Hugging Face Spaces due to the ease of use and wide adoption by the machine learning community.</p>
</div></blockquote>
</section>
<section id="deployed-gradio-app-structure">
<h3>8.2 Deployed Gradio app structure<a class="headerlink" href="#deployed-gradio-app-structure" title="Permalink to this heading">#</a></h3>
<p>To upload our demo Gradio app, we’ll want to put everything relating to it into a single directory.</p>
<p>For example, our demo might live at the path <code class="docutils literal notranslate"><span class="pre">demos/foodvision_mini/</span></code> with the file structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>demos/
└── foodvision_mini/
    ├── 09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth
    ├── app.py
    ├── examples/
    │   ├── example_1.jpg
    │   ├── example_2.jpg
    │   └── example_3.jpg
    ├── model.py
    └── requirements.txt
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth</span></code> is our trained PyTorch model file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">app.py</span></code> contains our Gradio app (similar to the code that launched the app).</p>
<ul>
<li><p><strong>Note:</strong> <code class="docutils literal notranslate"><span class="pre">app.py</span></code> is the default filename used for Hugging Face Spaces, if you deploy your app there, Spaces will by default look for a file called <code class="docutils literal notranslate"><span class="pre">app.py</span></code> to run. This is changable in settings.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">examples/</span></code> contains example images to use with our Gradio app.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">model.py</span></code> contains the model defintion as well as any transforms assosciated with the model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> contains the dependencies to run our app such as <code class="docutils literal notranslate"><span class="pre">torch</span></code>, <code class="docutils literal notranslate"><span class="pre">torchvision</span></code> and <code class="docutils literal notranslate"><span class="pre">gradio</span></code>.</p></li>
</ul>
<p>Why this way?</p>
<p>Because it’s one of the simplest layouts we could begin with.</p>
<p>Our focus is: <em>experiment, experiment, experiment!</em></p>
<p>The quicker we can run smaller experiments, the better our bigger ones will be.</p>
<p>We’re going to work towards recreating the structure above but you can see a live demo app running on Hugging Face Spaces as well as the file structure:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_mini">Live Gradio demo of FoodVision Mini 🍕🥩🍣</a>.</p></li>
<li><p><a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_mini/tree/main">FoodVision Mini file structure on Hugging Face Spaces</a>.</p></li>
</ul>
</section>
<section id="creating-a-demos-folder-to-store-our-foodvision-mini-app-files">
<h3>8.3 Creating a <code class="docutils literal notranslate"><span class="pre">demos</span></code> folder to store our FoodVision Mini app files<a class="headerlink" href="#creating-a-demos-folder-to-store-our-foodvision-mini-app-files" title="Permalink to this heading">#</a></h3>
<p>To begin, let’s first create a <code class="docutils literal notranslate"><span class="pre">demos/</span></code> directory to store all of our FoodVision Mini app files.</p>
<p>We can do with Python’s <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#basic-use"><code class="docutils literal notranslate"><span class="pre">pathlib.Path(&quot;path_to_dir&quot;)</span></code></a> to establish the directory path and <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir"><code class="docutils literal notranslate"><span class="pre">pathlib.Path(&quot;path_to_dir&quot;).mkdir()</span></code></a> to create it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># Create FoodVision mini demo path</span>
<span class="n">foodvision_mini_demo_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;demos/foodvision_mini/&quot;</span><span class="p">)</span>

<span class="c1"># Remove files that might already exist there and create new directory</span>
<span class="k">if</span> <span class="n">foodvision_mini_demo_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">foodvision_mini_demo_path</span><span class="p">)</span>
    <span class="n">foodvision_mini_demo_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1"># make the parent folders?</span>
                                    <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># create it even if it already exists?</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># If the file doesn&#39;t exist, create it anyway</span>
    <span class="n">foodvision_mini_demo_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                    <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
<span class="c1"># Check what&#39;s in the folder</span>
<span class="o">!</span>ls<span class="w"> </span>demos/foodvision_mini/
</pre></div>
</div>
</div>
</div>
</section>
<section id="creating-a-folder-of-example-images-to-use-with-our-foodvision-mini-demo">
<h3>8.4 Creating a folder of example images to use with our FoodVision Mini demo<a class="headerlink" href="#creating-a-folder-of-example-images-to-use-with-our-foodvision-mini-demo" title="Permalink to this heading">#</a></h3>
<p>Now we’ve got a directory to store our FoodVision Mini demo files, let’s add some examples to it.</p>
<p>Three example images from the test dataset should be enough.</p>
<p>To do so we’ll:</p>
<ol class="arabic simple">
<li><p>Create an <code class="docutils literal notranslate"><span class="pre">examples/</span></code> directory within the <code class="docutils literal notranslate"><span class="pre">demos/foodvision_mini</span></code> directory.</p></li>
<li><p>Choose three random images from the test dataset and collect their filepaths in a list.</p></li>
<li><p>Copy the three random images from the test dataset to the <code class="docutils literal notranslate"><span class="pre">demos/foodvision_mini/examples/</span></code> directory.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># 1. Create an examples directory</span>
<span class="n">foodvision_mini_examples_path</span> <span class="o">=</span> <span class="n">foodvision_mini_demo_path</span> <span class="o">/</span> <span class="s2">&quot;examples&quot;</span>
<span class="n">foodvision_mini_examples_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># 2. Collect three random test dataset image paths</span>
<span class="n">foodvision_mini_examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="s1">&#39;data/pizza_steak_sushi_20_percent/test/sushi/592799.jpg&#39;</span><span class="p">),</span>
                            <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;data/pizza_steak_sushi_20_percent/test/steak/3622237.jpg&#39;</span><span class="p">),</span>
                            <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;data/pizza_steak_sushi_20_percent/test/pizza/2582289.jpg&#39;</span><span class="p">)]</span>

<span class="c1"># 3. Copy the three random images to the examples directory</span>
<span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">foodvision_mini_examples</span><span class="p">:</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="n">foodvision_mini_examples_path</span> <span class="o">/</span> <span class="n">example</span><span class="o">.</span><span class="n">name</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Copying </span><span class="si">{</span><span class="n">example</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">destination</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">example</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] Copying data/pizza_steak_sushi_20_percent/test/sushi/592799.jpg to demos/foodvision_mini/examples/592799.jpg
[INFO] Copying data/pizza_steak_sushi_20_percent/test/steak/3622237.jpg to demos/foodvision_mini/examples/3622237.jpg
[INFO] Copying data/pizza_steak_sushi_20_percent/test/pizza/2582289.jpg to demos/foodvision_mini/examples/2582289.jpg
</pre></div>
</div>
</div>
</div>
<p>Now to verify our examples are present, let’s list the contents of our <code class="docutils literal notranslate"><span class="pre">demos/foodvision_mini/examples/</span></code> directory with <a class="reference external" href="https://docs.python.org/3/library/os.html#os.listdir"><code class="docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> and then format the filepaths into a list of lists (so it’s compatible with Gradio’s <a class="reference external" href="https://gradio.app/docs/#interface"><code class="docutils literal notranslate"><span class="pre">gradio.Interface()</span></code></a> <code class="docutils literal notranslate"><span class="pre">example</span></code> parameter).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Get example filepaths in a list of lists</span>
<span class="n">example_list</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;examples/&quot;</span> <span class="o">+</span> <span class="n">example</span><span class="p">]</span> <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">foodvision_mini_examples_path</span><span class="p">)]</span>
<span class="n">example_list</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[&#39;examples/3622237.jpg&#39;], [&#39;examples/592799.jpg&#39;], [&#39;examples/2582289.jpg&#39;]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="moving-our-trained-effnetb2-model-to-our-foodvision-mini-demo-directory">
<h3>8.5 Moving our trained EffNetB2 model to our FoodVision Mini demo directory<a class="headerlink" href="#moving-our-trained-effnetb2-model-to-our-foodvision-mini-demo-directory" title="Permalink to this heading">#</a></h3>
<p>We previously saved our FoodVision Mini EffNetB2 feature extractor model under <code class="docutils literal notranslate"><span class="pre">models/09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth</span></code>.</p>
<p>And rather double up on saved model files, let’s move our model to our <code class="docutils literal notranslate"><span class="pre">demos/foodvision_mini</span></code> directory.</p>
<p>We can do so using Python’s <a class="reference external" href="https://docs.python.org/3/library/shutil.html#shutil.move"><code class="docutils literal notranslate"><span class="pre">shutil.move()</span></code></a> method and passing in <code class="docutils literal notranslate"><span class="pre">src</span></code> (the source path of the target file) and <code class="docutils literal notranslate"><span class="pre">dst</span></code> (the destination path of the target file to be moved to) parameters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">shutil</span>

<span class="c1"># Create a source path for our target model</span>
<span class="n">effnetb2_foodvision_mini_model_path</span> <span class="o">=</span> <span class="s2">&quot;models/09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth&quot;</span>

<span class="c1"># Create a destination path for our target model </span>
<span class="n">effnetb2_foodvision_mini_model_destination</span> <span class="o">=</span> <span class="n">foodvision_mini_demo_path</span> <span class="o">/</span> <span class="n">effnetb2_foodvision_mini_model_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Try to move the file</span>
<span class="k">try</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Attempting to move </span><span class="si">{</span><span class="n">effnetb2_foodvision_mini_model_path</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">effnetb2_foodvision_mini_model_destination</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Move the model</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">effnetb2_foodvision_mini_model_path</span><span class="p">,</span> 
                <span class="n">dst</span><span class="o">=</span><span class="n">effnetb2_foodvision_mini_model_destination</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Model move complete.&quot;</span><span class="p">)</span>

<span class="c1"># If the model has already been moved, check if it exists</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] No model found at </span><span class="si">{</span><span class="n">effnetb2_foodvision_mini_model_path</span><span class="si">}</span><span class="s2">, perhaps its already been moved?&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Model exists at </span><span class="si">{</span><span class="n">effnetb2_foodvision_mini_model_destination</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">effnetb2_foodvision_mini_model_destination</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] Attempting to move models/09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth to demos/foodvision_mini/09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth
[INFO] Model move complete.
</pre></div>
</div>
</div>
</div>
</section>
<section id="turning-our-effnetb2-model-into-a-python-script-model-py">
<h3>8.6 Turning our EffNetB2 model into a Python script (<code class="docutils literal notranslate"><span class="pre">model.py</span></code>)<a class="headerlink" href="#turning-our-effnetb2-model-into-a-python-script-model-py" title="Permalink to this heading">#</a></h3>
<p>Our current model’s <code class="docutils literal notranslate"><span class="pre">state_dict</span></code> is saved to <code class="docutils literal notranslate"><span class="pre">demos/foodvision_mini/09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth</span></code>.</p>
<p>To load it in we can use <code class="docutils literal notranslate"><span class="pre">model.load_state_dict()</span></code> along with <code class="docutils literal notranslate"><span class="pre">torch.load()</span></code>.</p>
<blockquote>
<div><p><strong>Note:</strong> For a refresh on saving and loading a model (or a model’s <code class="docutils literal notranslate"><span class="pre">state_dict</span></code> in PyTorch, see <a class="reference external" href="https://www.learnpytorch.io/01_pytorch_workflow/#5-saving-and-loading-a-pytorch-model">01. PyTorch Workflow Fundamentals section 5: Saving and loading a PyTorch model</a> or see the PyTorch recipe for <a class="reference external" href="https://pytorch.org/tutorials/recipes/recipes/what_is_state_dict.html">What is a <code class="docutils literal notranslate"><span class="pre">state_dict</span></code> in PyTorch?</a></p>
</div></blockquote>
<p>But before we can do this, we first need a way to instantiate a <code class="docutils literal notranslate"><span class="pre">model</span></code>.</p>
<p>To do this in a modular fashion we’ll create a script called <code class="docutils literal notranslate"><span class="pre">model.py</span></code> which contains our <code class="docutils literal notranslate"><span class="pre">create_effnetb2_model()</span></code> function we created in <a class="reference external" href="https://www.learnpytorch.io/09_pytorch_model_deployment/#31-creating-a-function-to-make-an-effnetb2-feature-extractor">section 3.1: <em>Creating a function to make an EffNetB2 feature extractor</em></a>.</p>
<p>That way we can import the function in <em>another</em> script (see <code class="docutils literal notranslate"><span class="pre">app.py</span></code> below) and then use it to create our EffNetB2 <code class="docutils literal notranslate"><span class="pre">model</span></code> instance as well as get its appropriate transforms.</p>
<p>Just like in <a class="reference external" href="https://www.learnpytorch.io/05_pytorch_going_modular/">05. PyTorch Going Modular</a>, we’ll use the <code class="docutils literal notranslate"><span class="pre">%%writefile</span> <span class="pre">path/to/file</span></code> magic command to turn a cell of code into a file.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%writefile</span> demos/foodvision_mini/model.py
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torchvision</span>

<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>


<span class="k">def</span> <span class="nf">create_effnetb2_model</span><span class="p">(</span><span class="n">num_classes</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                          <span class="n">seed</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates an EfficientNetB2 feature extractor model and transforms.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_classes (int, optional): number of classes in the classifier head. </span>
<span class="sd">            Defaults to 3.</span>
<span class="sd">        seed (int, optional): random seed value. Defaults to 42.</span>

<span class="sd">    Returns:</span>
<span class="sd">        model (torch.nn.Module): EffNetB2 feature extractor model. </span>
<span class="sd">        transforms (torchvision.transforms): EffNetB2 image transforms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create EffNetB2 pretrained weights, transforms and model</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">EfficientNet_B2_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
    <span class="n">transforms</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">transforms</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">efficientnet_b2</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Freeze all layers in base model</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
        <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Change classifier head with random seed for reproducibility</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">1408</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="n">num_classes</span><span class="p">),</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">transforms</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Writing demos/foodvision_mini/model.py
</pre></div>
</div>
</div>
</div>
</section>
<section id="turning-our-foodvision-mini-gradio-app-into-a-python-script-app-py">
<h3>8.7 Turning our FoodVision Mini Gradio app into a Python script (<code class="docutils literal notranslate"><span class="pre">app.py</span></code>)<a class="headerlink" href="#turning-our-foodvision-mini-gradio-app-into-a-python-script-app-py" title="Permalink to this heading">#</a></h3>
<p>We’ve now got a <code class="docutils literal notranslate"><span class="pre">model.py</span></code> script as well as a path to a saved model <code class="docutils literal notranslate"><span class="pre">state_dict</span></code> that we can load in.</p>
<p>Time to construct <code class="docutils literal notranslate"><span class="pre">app.py</span></code>.</p>
<p>We call it <code class="docutils literal notranslate"><span class="pre">app.py</span></code> because by default when you create a HuggingFace Space, it looks for a file called <code class="docutils literal notranslate"><span class="pre">app.py</span></code> to run and host (though you can change this in settings).</p>
<p>Our <code class="docutils literal notranslate"><span class="pre">app.py</span></code> script will put together all of the pieces of the puzzle to create our Gradio demo and will have four main parts:</p>
<ol class="arabic simple">
<li><p><strong>Imports and class names setup</strong> - Here we’ll import the various dependencies for our demo including the <code class="docutils literal notranslate"><span class="pre">create_effnetb2_model()</span></code> function from <code class="docutils literal notranslate"><span class="pre">model.py</span></code> as well as setup the different class names for our FoodVision Mini app.</p></li>
<li><p><strong>Model and transforms preparation</strong> - Here we’ll create an EffNetB2 model instance along with the transforms to go with it and then we’ll load in the saved model weights/<code class="docutils literal notranslate"><span class="pre">state_dict</span></code>. When we load the model we’ll also set <code class="docutils literal notranslate"><span class="pre">map_location=torch.device(&quot;cpu&quot;)</span></code> in <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.load.html"><code class="docutils literal notranslate"><span class="pre">torch.load()</span></code></a> so our model gets loaded onto the CPU regardless of the device it trained on (we do this because we won’t necessarily have a GPU when we deploy and we’ll get an error if our model is trained on GPU but we try to deploy it to CPU without explicitly saying so).</p></li>
<li><p><strong>Predict function</strong> - Gradio’s <code class="docutils literal notranslate"><span class="pre">gradio.Interface()</span></code> takes a <code class="docutils literal notranslate"><span class="pre">fn</span></code> parameter to map inputs to outputs, our <code class="docutils literal notranslate"><span class="pre">predict()</span></code> function will be the same as the one we defined above in <a class="reference external" href="https://www.learnpytorch.io/09_pytorch_model_deployment/#72-creating-a-function-to-map-our-inputs-and-outputs">section 7.2: <em>Creating a function to map our inputs and outputs</em></a>, it will take in an image and then use the loaded transforms to preprocess it before using the loaded model to make a prediction on it.</p>
<ul class="simple">
<li><p><strong>Note:</strong> We’ll have to create the example list on the fly via the <code class="docutils literal notranslate"><span class="pre">examples</span></code> parameter. We can do so by creating a list of the files inside the <code class="docutils literal notranslate"><span class="pre">examples/</span></code> directory with: <code class="docutils literal notranslate"><span class="pre">[[&quot;examples/&quot;</span> <span class="pre">+</span> <span class="pre">example]</span> <span class="pre">for</span> <span class="pre">example</span> <span class="pre">in</span> <span class="pre">os.listdir(&quot;examples&quot;)]</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Gradio app</strong> - This is where the main logic of our demo will live, we’ll create a <code class="docutils literal notranslate"><span class="pre">gradio.Interface()</span></code> instance called <code class="docutils literal notranslate"><span class="pre">demo</span></code> to put together our inputs, <code class="docutils literal notranslate"><span class="pre">predict()</span></code> function and outputs. And we’ll finish the script by calling <code class="docutils literal notranslate"><span class="pre">demo.launch()</span></code> to launch our FoodVision Mini demo!</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%writefile</span> demos/foodvision_mini/app.py
<span class="c1">### 1. Imports and class names setup ### </span>
<span class="kn">import</span> <span class="nn">gradio</span> <span class="k">as</span> <span class="nn">gr</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">model</span> <span class="kn">import</span> <span class="n">create_effnetb2_model</span>
<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># Setup class names</span>
<span class="n">class_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;pizza&quot;</span><span class="p">,</span> <span class="s2">&quot;steak&quot;</span><span class="p">,</span> <span class="s2">&quot;sushi&quot;</span><span class="p">]</span>

<span class="c1">### 2. Model and transforms preparation ###</span>

<span class="c1"># Create EffNetB2 model</span>
<span class="n">effnetb2</span><span class="p">,</span> <span class="n">effnetb2_transforms</span> <span class="o">=</span> <span class="n">create_effnetb2_model</span><span class="p">(</span>
    <span class="n">num_classes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="c1"># len(class_names) would also work</span>
<span class="p">)</span>

<span class="c1"># Load saved weights</span>
<span class="n">effnetb2</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
        <span class="n">f</span><span class="o">=</span><span class="s2">&quot;09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth&quot;</span><span class="p">,</span>
        <span class="n">map_location</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">),</span>  <span class="c1"># load to CPU</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="c1">### 3. Predict function ###</span>

<span class="c1"># Create predict function</span>
<span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transforms and performs a prediction on img and returns prediction and time taken.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Start the timer</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    
    <span class="c1"># Transform the target image and add a batch dimension</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">effnetb2_transforms</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Put model into evaluation mode and turn on inference mode</span>
    <span class="n">effnetb2</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">inference_mode</span><span class="p">():</span>
        <span class="c1"># Pass the transformed image through the model and turn the prediction logits into prediction probabilities</span>
        <span class="n">pred_probs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">effnetb2</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Create a prediction label and prediction probability dictionary for each prediction class (this is the required format for Gradio&#39;s output parameter)</span>
    <span class="n">pred_labels_and_probs</span> <span class="o">=</span> <span class="p">{</span><span class="n">class_names</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="nb">float</span><span class="p">(</span><span class="n">pred_probs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">class_names</span><span class="p">))}</span>
    
    <span class="c1"># Calculate the prediction time</span>
    <span class="n">pred_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    
    <span class="c1"># Return the prediction dictionary and prediction time </span>
    <span class="k">return</span> <span class="n">pred_labels_and_probs</span><span class="p">,</span> <span class="n">pred_time</span>

<span class="c1">### 4. Gradio app ###</span>

<span class="c1"># Create title, description and article strings</span>
<span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;FoodVision Mini 🍕🥩🍣&quot;</span>
<span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;An EfficientNetB2 feature extractor computer vision model to classify images of food as pizza, steak or sushi.&quot;</span>
<span class="n">article</span> <span class="o">=</span> <span class="s2">&quot;Created at [09. PyTorch Model Deployment](https://www.learnpytorch.io/09_pytorch_model_deployment/).&quot;</span>

<span class="c1"># Create examples list from &quot;examples/&quot; directory</span>
<span class="n">example_list</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;examples/&quot;</span> <span class="o">+</span> <span class="n">example</span><span class="p">]</span> <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;examples&quot;</span><span class="p">)]</span>

<span class="c1"># Create the Gradio demo</span>
<span class="n">demo</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">Interface</span><span class="p">(</span><span class="n">fn</span><span class="o">=</span><span class="n">predict</span><span class="p">,</span> <span class="c1"># mapping function from input to output</span>
                    <span class="n">inputs</span><span class="o">=</span><span class="n">gr</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;pil&quot;</span><span class="p">),</span> <span class="c1"># what are the inputs?</span>
                    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">gr</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="n">num_top_classes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Predictions&quot;</span><span class="p">),</span> <span class="c1"># what are the outputs?</span>
                             <span class="n">gr</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Prediction time (s)&quot;</span><span class="p">)],</span> <span class="c1"># our fn has two outputs, therefore we have two outputs</span>
                    <span class="c1"># Create examples list from &quot;examples/&quot; directory</span>
                    <span class="n">examples</span><span class="o">=</span><span class="n">example_list</span><span class="p">,</span> 
                    <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                    <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
                    <span class="n">article</span><span class="o">=</span><span class="n">article</span><span class="p">)</span>

<span class="c1"># Launch the demo!</span>
<span class="n">demo</span><span class="o">.</span><span class="n">launch</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Writing demos/foodvision_mini/app.py
</pre></div>
</div>
</div>
</div>
</section>
<section id="creating-a-requirements-file-for-foodvision-mini-requirements-txt">
<h3>8.8 Creating a requirements file for FoodVision Mini (<code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>)<a class="headerlink" href="#creating-a-requirements-file-for-foodvision-mini-requirements-txt" title="Permalink to this heading">#</a></h3>
<p>The last file we need to create for our FoodVision Mini app is a <a class="reference external" href="https://learnpython.com/blog/python-requirements-file/"><code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> file</a>.</p>
<p>This will be a text file containing all of the required dependencies for our demo.</p>
<p>When we deploy our demo app to Hugging Face Spaces, it will search through this file and install the dependencies we define so our app can run.</p>
<p>The good news is, there’s only three!</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">torch==1.12.0</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">torchvision==0.13.0</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gradio==3.1.4</span></code></p></li>
</ol>
<p>The “<code class="docutils literal notranslate"><span class="pre">==1.12.0</span></code>” states the version number to install.</p>
<p>Defining the version number is not 100% required but we will for now so if any breaking updates occur in future releases, our app still runs (PS if you find any errors, feel free to post on the course <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/issues">GitHub Issues</a>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%writefile</span> demos/foodvision_mini/requirements.txt
<span class="n">torch</span><span class="o">==</span><span class="mf">1.12.0</span>
<span class="n">torchvision</span><span class="o">==</span><span class="mf">0.13.0</span>
<span class="n">gradio</span><span class="o">==</span><span class="mf">3.1.4</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Writing demos/foodvision_mini/requirements.txt
</pre></div>
</div>
</div>
</div>
<p>Nice!</p>
<p>We’ve officially got all the files we need to deploy our FoodVision Mini demo!</p>
</section>
</section>
<section id="deploying-our-foodvision-mini-app-to-huggingface-spaces">
<h2>9. Deploying our FoodVision Mini app to HuggingFace Spaces<a class="headerlink" href="#deploying-our-foodvision-mini-app-to-huggingface-spaces" title="Permalink to this heading">#</a></h2>
<p>We’ve got a file containing our FoodVision Mini demo, now how do we get it to run on Hugging Face Spaces?</p>
<p>There are two main options for uploading to a Hugging Face Space (also called a <a class="reference external" href="https://huggingface.co/docs/hub/repositories-getting-started#getting-started-with-repositories">Hugging Face Repository</a>, similar to a git repository):</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://huggingface.co/docs/hub/repositories-getting-started#adding-files-to-a-repository-web-ui">Uploading via the Hugging Face Web interface (easiest)</a>.</p></li>
<li><p><a class="reference external" href="https://huggingface.co/docs/hub/repositories-getting-started#terminal">Uploading via the command line or terminal</a>.</p>
<ul class="simple">
<li><p><strong>Bonus:</strong> You can also use the <a class="reference external" href="https://huggingface.co/docs/huggingface_hub/index"><code class="docutils literal notranslate"><span class="pre">huggingface_hub</span></code> library</a> to interact with Hugging Face, this would be a good extension to the above two options.</p></li>
</ul>
</li>
</ol>
<p>Feel free to read the documentation on both options but we’re going to go with option two.</p>
<blockquote>
<div><p><strong>Note:</strong> To host anything on Hugging Face, you will to <a class="reference external" href="https://huggingface.co/join">sign up for a free Hugging Face account</a>.</p>
</div></blockquote>
<section id="downloading-our-foodvision-mini-app-files">
<h3>9.1 Downloading our FoodVision Mini app files<a class="headerlink" href="#downloading-our-foodvision-mini-app-files" title="Permalink to this heading">#</a></h3>
<p>Let’s check out the demo files we’ve got inside <code class="docutils literal notranslate"><span class="pre">demos/foodvision_mini</span></code>.</p>
<p>To do so we can use the <code class="docutils literal notranslate"><span class="pre">!ls</span></code> command followed by the target filepath.</p>
<p><code class="docutils literal notranslate"><span class="pre">ls</span></code> stands for “list” and the <code class="docutils literal notranslate"><span class="pre">!</span></code> means we want to execute the command at the shell level.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>ls<span class="w"> </span>demos/foodvision_mini
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth
app.py
examples
model.py
requirements.txt
</pre></div>
</div>
</div>
</div>
<p>These are all files that we’ve created!</p>
<p>To begin uploading our files to Hugging Face, let’s now download them from Google Colab (or wherever you’re running this notebook).</p>
<p>To do so, we’ll first compress the files into a single zip folder via the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">zip</span> <span class="o">-</span><span class="n">r</span> <span class="o">../</span><span class="n">foodvision_mini</span><span class="o">.</span><span class="n">zip</span> <span class="o">*</span> <span class="o">-</span><span class="n">x</span> <span class="s2">&quot;*.pyc&quot;</span> <span class="s2">&quot;*.ipynb&quot;</span> <span class="s2">&quot;*__pycache__*&quot;</span> <span class="s2">&quot;*ipynb_checkpoints*&quot;</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">zip</span></code> stands for “zip” as in “please zip together the files in the following directory”.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-r</span></code> stands for “recursive” as in, “go through all of the files in the target directory”.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">../foodvision_mini.zip</span></code> is the target directory we’d like our files to be zipped to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">*</span></code> stands for “all the files in the current directory”.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-x</span></code> stands for “exclude these files”.</p></li>
</ul>
<p>We can download our zip file from Google Colab using <a class="reference external" href="https://colab.research.google.com/notebooks/io.ipynb"><code class="docutils literal notranslate"><span class="pre">google.colab.files.download(&quot;demos/foodvision_mini.zip&quot;)</span></code></a> (we’ll put this inside a <code class="docutils literal notranslate"><span class="pre">try</span></code> and <code class="docutils literal notranslate"><span class="pre">except</span></code> block just in case we’re not running the code inside Google Colab, and if so we’ll print a message saying to manually download the files).</p>
<p>Let’s try it out!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Change into and then zip the foodvision_mini folder but exclude certain files</span>
<span class="o">!</span><span class="nb">cd</span><span class="w"> </span>demos/foodvision_mini<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>zip<span class="w"> </span>-r<span class="w"> </span>../foodvision_mini.zip<span class="w"> </span>*<span class="w"> </span>-x<span class="w"> </span><span class="s2">&quot;*.pyc&quot;</span><span class="w"> </span><span class="s2">&quot;*.ipynb&quot;</span><span class="w"> </span><span class="s2">&quot;*__pycache__*&quot;</span><span class="w"> </span><span class="s2">&quot;*ipynb_checkpoints*&quot;</span>

<span class="c1"># Download the zipped FoodVision Mini app (if running in Google Colab)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">google.colab</span> <span class="kn">import</span> <span class="n">files</span>
    <span class="n">files</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="s2">&quot;demos/foodvision_mini.zip&quot;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not running in Google Colab, can&#39;t use google.colab.files.download(), please manually download.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>updating: 09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth (deflated 8%)
updating: app.py (deflated 57%)
updating: examples/ (stored 0%)
updating: examples/3622237.jpg (deflated 0%)
updating: examples/592799.jpg (deflated 1%)
updating: examples/2582289.jpg (deflated 17%)
updating: model.py (deflated 56%)
updating: requirements.txt (deflated 4%)
Not running in Google Colab, can&#39;t use google.colab.files.download(), please manually download.
</pre></div>
</div>
</div>
</div>
<p>Woohoo!</p>
<p>Looks like our <code class="docutils literal notranslate"><span class="pre">zip</span></code> command was successful.</p>
<p>If you’re running this notebook in Google Colab, you should see a file start to download in your browser.</p>
<p>Otherwise, you can see the <code class="docutils literal notranslate"><span class="pre">foodvision_mini.zip</span></code> folder (and more) on the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/tree/main/demos">course GitHub under the <code class="docutils literal notranslate"><span class="pre">demos/</span></code> directory</a>.</p>
</section>
<section id="running-our-foodvision-mini-demo-locally">
<h3>9.2 Running our FoodVision Mini demo locally<a class="headerlink" href="#running-our-foodvision-mini-demo-locally" title="Permalink to this heading">#</a></h3>
<p>If you download the <code class="docutils literal notranslate"><span class="pre">foodvision_mini.zip</span></code> file, you can test it locally by:</p>
<ol class="arabic simple">
<li><p>Unzipping the file.</p></li>
<li><p>Opening terminal or a command line prompt.</p></li>
<li><p>Changing into the <code class="docutils literal notranslate"><span class="pre">foodvision_mini</span></code> directory (<code class="docutils literal notranslate"><span class="pre">cd</span> <span class="pre">foodvision_mini</span></code>).</p></li>
<li><p>Creating an environment (<code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">-m</span> <span class="pre">venv</span> <span class="pre">env</span></code>).</p></li>
<li><p>Activating the environment (<code class="docutils literal notranslate"><span class="pre">source</span> <span class="pre">env/bin/activate</span></code>).</p></li>
<li><p>Installing the requirements (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">-r</span> <span class="pre">requirements.txt</span></code>, the “<code class="docutils literal notranslate"><span class="pre">-r</span></code>” is for recursive).</p>
<ul class="simple">
<li><p><strong>Note:</strong> This step may take 5-10 minutes depending on your internet connection. And if you’re facing errors, you may need to upgrade <code class="docutils literal notranslate"><span class="pre">pip</span></code> first: <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--upgrade</span> <span class="pre">pip</span></code>.</p></li>
</ul>
</li>
<li><p>Run the app (<code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">app.py</span></code>).</p></li>
</ol>
<p>This should result in a Gradio demo just like the one we built above running locally on your machine at a URL such as <code class="docutils literal notranslate"><span class="pre">http://127.0.0.1:7860/</span></code>.</p>
<blockquote>
<div><p><strong>Note:</strong> If you run the app locally and you notice a <code class="docutils literal notranslate"><span class="pre">flagged/</span></code> directory appear, it contains samples that have been “flagged”.</p>
<p>For example, if someone tries the demo and the model produces an incorrect result, the sample can be “flagged” and reviewed for later.</p>
<p>For more on flagging in Gradio, see the <a class="reference external" href="https://gradio.app/docs/#flagging">flagging documentation</a>.</p>
</div></blockquote>
</section>
<section id="uploading-to-hugging-face">
<h3>9.3 Uploading to Hugging Face<a class="headerlink" href="#uploading-to-hugging-face" title="Permalink to this heading">#</a></h3>
<p>We’ve verfied our FoodVision Mini app works locally, however, the fun of creating a machine learning demo is to show it to other people and allow them to use it.</p>
<p>To do so, we’re going to upload our FoodVision Mini demo to Hugging Face.</p>
<blockquote>
<div><p><strong>Note:</strong> The following series of steps uses a Git (a file tracking system) workflow. For more on how Git works, I’d recommend going through the <a class="reference external" href="https://youtu.be/RGOj5yH7evk">Git and GitHub for Beginners tutorial</a> on freeCodeCamp.</p>
</div></blockquote>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://huggingface.co/join">Sign up</a> for a Hugging Face account.</p></li>
<li><p>Start a new Hugging Face Space by going to your profile and then <a class="reference external" href="https://huggingface.co/new-space">clicking “New Space”</a>.</p>
<ul class="simple">
<li><p><strong>Note:</strong> A Space in Hugging Face is also known as a “code repository” (a place to store your code/files) or “repo” for short.</p></li>
</ul>
</li>
<li><p>Give the Space a name, for example, mine is called <code class="docutils literal notranslate"><span class="pre">thangckt/foodvision_mini</span></code>, you can see it here: <a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_mini">https://huggingface.co/spaces/thangckt/foodvision_mini</a></p></li>
<li><p>Select a license (I used <a class="reference external" href="https://opensource.org/licenses/MIT">MIT</a>).</p></li>
<li><p>Select Gradio as the Space SDK (software development kit).</p>
<ul class="simple">
<li><p><strong>Note:</strong> You can use other options such as Streamlit but since our app is built with Gradio, we’ll stick with that.</p></li>
</ul>
</li>
<li><p>Choose whether your Space is it’s public or private (I selected public since I’d like my Space to be available to others).</p></li>
<li><p>Click “Create Space”.</p></li>
<li><p>Clone the repo locally by running something like: <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span> <span class="pre">https://huggingface.co/spaces/[YOUR_USERNAME]/[YOUR_SPACE_NAME]</span></code> in terminal or command prompt.</p>
<ul class="simple">
<li><p><strong>Note:</strong> You can also add files via uploading them under the “Files and versions” tab.</p></li>
</ul>
</li>
<li><p>Copy/move the contents of the downloaded <code class="docutils literal notranslate"><span class="pre">foodvision_mini</span></code> folder to the cloned repo folder.</p></li>
<li><p>To upload and track larger files (e.g. files over 10MB or in our case, our PyTorch model file) you’ll need to <a class="reference external" href="https://git-lfs.github.com/">install Git LFS</a> (which stands for “git large file storage”).</p></li>
<li><p>After you’ve installed Git LFS, you can activate it by running <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">lfs</span> <span class="pre">install</span></code>.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">foodvision_mini</span></code> directory, track the files over 10MB with Git LFS with <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">lfs</span> <span class="pre">track</span> <span class="pre">&quot;*.file_extension&quot;</span></code>.</p>
<ul class="simple">
<li><p>Track EffNetB2 PyTorch model file with <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">lfs</span> <span class="pre">track</span> <span class="pre">&quot;09_pretrained_effnetb2_feature_extractor_pizza_steak_sushi_20_percent.pth&quot;</span></code>.</p></li>
</ul>
</li>
<li><p>Track <code class="docutils literal notranslate"><span class="pre">.gitattributes</span></code> (automatically created when cloning from HuggingFace, this file will help ensure our larger files are tracked with Git LFS). You can see an example <code class="docutils literal notranslate"><span class="pre">.gitattributes</span></code> file on the <a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_mini/blob/main/.gitattributes">FoodVision Mini Hugging Face Space</a>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">add</span> <span class="pre">.gitattributes</span></code></p></li>
</ul>
</li>
<li><p>Add the rest of the <code class="docutils literal notranslate"><span class="pre">foodvision_mini</span></code> app files and commit them with:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">add</span> <span class="pre">*</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">commit</span> <span class="pre">-m</span> <span class="pre">&quot;first</span> <span class="pre">commit&quot;</span></code></p></li>
</ul>
</li>
<li><p>Push (upload) the files to Hugging Face:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">push</span></code></p></li>
</ul>
</li>
<li><p>Wait 3-5 minutes for the build to happen (future builds are faster) and your app to become live!</p></li>
</ol>
<p>If everything worked, you should see a live running example of our FoodVision Mini Gradio demo like the one here: <a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_mini">https://huggingface.co/spaces/thangckt/foodvision_mini</a></p>
<p>And we can even embed our FoodVision Mini Gradio demo into our notebook as an <a class="reference external" href="https://gradio.app/sharing_your_app/#embedding-with-iframes">iframe</a> with <a class="reference external" href="https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html#IPython.display.IFrame"><code class="docutils literal notranslate"><span class="pre">IPython.display.IFrame</span></code></a> and a link to our space in the format <code class="docutils literal notranslate"><span class="pre">https://hf.space/embed/[YOUR_USERNAME]/[YOUR_SPACE_NAME]/+</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># IPython is a library to help make Python interactive</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">IFrame</span>

<span class="c1"># Embed FoodVision Mini Gradio demo</span>
<span class="n">IFrame</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="s2">&quot;https://hf.space/embed/thangckt/foodvision_mini/+&quot;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s2">&quot;width:900px&quot;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">750</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
        <iframe
            width="900"
            height="750"
            src="https://hf.space/embed/mrdbourke/foodvision_mini/+"
            frameborder="0"
            allowfullscreen
            
        ></iframe>
        </div></div>
</div>
</section>
</section>
<section id="creating-foodvision-big">
<h2>10. Creating FoodVision Big<a class="headerlink" href="#creating-foodvision-big" title="Permalink to this heading">#</a></h2>
<p>We’ve spent the past few sections and chapters working on bringing FoodVision Mini to life.</p>
<p>And now we’ve seen it working in a live demo, how about we step things up a notch?</p>
<p>How?</p>
<p>FoodVision Big!</p>
<p>Since FoodVision Mini is trained on pizza, steak and sushi images from the <a class="reference external" href="https://pytorch.org/vision/main/generated/torchvision.datasets.Food101.html">Food101 dataset</a> (101 classes of food x 1000 images each), how about we make FoodVision Big by training a model on all 101 classes!</p>
<p>We’ll go from three classes to 101!</p>
<p>From pizza, steak, sushi to pizza, steak, sushi, hot dog, apple pie, carrot cake, chocolate cake, french fires, garlic bread, ramen, nachos, tacos and more!</p>
<p>How?</p>
<p>Well, we’ve got all the steps in place, all we have to do is alter our EffNetB2 model slightly as well as prepare a different dataset.</p>
<p>To finish Milestone Project 3, let’s recreate a Gradio demo similar to FoodVision Mini (three classes) but for FoodVision Big (101 classes).</p>
<img alt="foodvision mini model on three classes pizza, steak, sushi and foodvision big on all of the 101 classes in the food101 dataset" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-model-deployment-foodvision-mini-to-foodvision-big.png" />
<p><em>FoodVision Mini works with three food classes: pizza, steak and sushi. And FoodVision Big steps it up a notch to work across 101 food classes: all of the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/extras/food101_class_names.txt">classes in the Food101 dataset</a>.</em></p>
<section id="creating-a-model-and-transforms-for-foodvision-big">
<h3>10.1 Creating a model and transforms for FoodVision Big<a class="headerlink" href="#creating-a-model-and-transforms-for-foodvision-big" title="Permalink to this heading">#</a></h3>
<p>When creating FoodVision Mini we saw that the EffNetB2 model was a good tradeoff between speed and performance (it performed well with a fast speed).</p>
<p>So we’ll continue using the same model for FoodVision Big.</p>
<p>We can create an EffNetB2 feature extractor for Food101 by using our <code class="docutils literal notranslate"><span class="pre">create_effnetb2_model()</span></code> function we created above, in <a class="reference external" href="https://www.learnpytorch.io/09_pytorch_model_deployment/#31-creating-a-function-to-make-an-effnetb2-feature-extractor">section 3.1</a>, and passing it the parameter <code class="docutils literal notranslate"><span class="pre">num_classes=101</span></code> (since Food101 has 101 classes).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create EffNetB2 model capable of fitting to 101 classes for Food101</span>
<span class="n">effnetb2_food101</span><span class="p">,</span> <span class="n">effnetb2_transforms</span> <span class="o">=</span> <span class="n">create_effnetb2_model</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Beautiful!</p>
<p>Let’s now get a summary of our model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torchinfo</span> <span class="kn">import</span> <span class="n">summary</span>

<span class="c1"># # Get a summary of EffNetB2 feature extractor for Food101 with 101 output classes (uncomment for full output)</span>
<span class="c1"># summary(effnetb2_food101, </span>
<span class="c1">#         input_size=(1, 3, 224, 224),</span>
<span class="c1">#         col_names=[&quot;input_size&quot;, &quot;output_size&quot;, &quot;num_params&quot;, &quot;trainable&quot;],</span>
<span class="c1">#         col_width=20,</span>
<span class="c1">#         row_settings=[&quot;var_names&quot;])</span>
</pre></div>
</div>
</div>
</div>
<img alt="effnetb2 feature extractor with 100 output classes model summary" src="https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/09-effnetb2-feature-extractor-101-classes.png" />
<p>Nice!</p>
<p>See how just like our EffNetB2 model for FoodVision Mini the base layers are frozen (these are pretrained on ImageNet) and the outer layers (the <code class="docutils literal notranslate"><span class="pre">classifier</span></code> layers) are trainble with an ouput shape of <code class="docutils literal notranslate"><span class="pre">[batch_size,</span> <span class="pre">101]</span></code> (<code class="docutils literal notranslate"><span class="pre">101</span></code> for 101 classes in Food101).</p>
<p>Now since we’re going to be dealing with a fair bit more data than usual, how about we add a little data augmentation to our transforms (<code class="docutils literal notranslate"><span class="pre">effnetb2_transforms</span></code>) to augment the training data.</p>
<blockquote>
<div><p><strong>Note:</strong> Data augmentation is a technique used to alter the appearance of an input training sample (e.g. rotating an image or slightly skewing it) to artificially increase the diversity of a training dataset to hopefully prevent overfitting. You can see more on data augmentation in <a class="reference external" href="https://www.learnpytorch.io/04_pytorch_custom_datasets/#6-other-forms-of-transforms-data-augmentation">04. PyTorch Custom Datasets section 6</a>.</p>
</div></blockquote>
<p>Let’s compose a <code class="docutils literal notranslate"><span class="pre">torchvision.transforms</span></code> pipeline to use <a class="reference external" href="https://pytorch.org/vision/main/generated/torchvision.transforms.TrivialAugmentWide.html"><code class="docutils literal notranslate"><span class="pre">torchvision.transforms.TrivialAugmentWide()</span></code></a> (the same data augmentation used by the PyTorch team in their <a class="reference external" href="https://pytorch.org/blog/how-to-train-state-of-the-art-models-using-torchvision-latest-primitives/#break-down-of-key-accuracy-improvements">computer vision recipes</a>) as well as the <code class="docutils literal notranslate"><span class="pre">effnetb2_transforms</span></code> to transform our training images.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Food101 training data transforms (only perform data augmentation on the training images)</span>
<span class="n">food101_train_transforms</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
    <span class="n">torchvision</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">TrivialAugmentWide</span><span class="p">(),</span>
    <span class="n">effnetb2_transforms</span><span class="p">,</span>
<span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Epic!</p>
<p>Now let’s compare <code class="docutils literal notranslate"><span class="pre">food101_train_transforms</span></code> (for the training data) and <code class="docutils literal notranslate"><span class="pre">effnetb2_transforms</span></code> (for the testing/inference data).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Training transforms:</span><span class="se">\n</span><span class="si">{</span><span class="n">food101_train_transforms</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> 
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Testing transforms:</span><span class="se">\n</span><span class="si">{</span><span class="n">effnetb2_transforms</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Training transforms:
Compose(
    TrivialAugmentWide(num_magnitude_bins=31, interpolation=InterpolationMode.NEAREST, fill=None)
    ImageClassification(
    crop_size=[288]
    resize_size=[288]
    mean=[0.485, 0.456, 0.406]
    std=[0.229, 0.224, 0.225]
    interpolation=InterpolationMode.BICUBIC
)
)

Testing transforms:
ImageClassification(
    crop_size=[288]
    resize_size=[288]
    mean=[0.485, 0.456, 0.406]
    std=[0.229, 0.224, 0.225]
    interpolation=InterpolationMode.BICUBIC
)
</pre></div>
</div>
</div>
</div>
</section>
<section id="getting-data-for-foodvision-big">
<h3>10.2 Getting data for FoodVision Big<a class="headerlink" href="#getting-data-for-foodvision-big" title="Permalink to this heading">#</a></h3>
<p>For FoodVision Mini, we made our own <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/extras/04_custom_data_creation.ipynb">custom data splits</a> of the entire Food101 dataset.</p>
<p>To get the whole Food101 dataset, we can use <a class="reference external" href="https://pytorch.org/vision/main/generated/torchvision.datasets.Food101.html"><code class="docutils literal notranslate"><span class="pre">torchvision.datasets.Food101()</span></code></a>.</p>
<p>We’ll first setup a path to directory <code class="docutils literal notranslate"><span class="pre">data/</span></code> to store the images.</p>
<p>Then we’ll download and transform the training and testing dataset splits using <code class="docutils literal notranslate"><span class="pre">food101_train_transforms</span></code> and <code class="docutils literal notranslate"><span class="pre">effnetb2_transforms</span></code> to transform each dataset respectively.</p>
<blockquote>
<div><p><strong>Note:</strong> If you’re using Google Colab, the cell below will take ~3-5 minutes to fully run and download the Food101 images from PyTorch.</p>
<p>This is because there is over 100,000 images being downloaded (101 classes x 1000 images per class). If you restart your Google Colab runtime and come back to this cell, the images will have to redownload. Alternatively, if you’re running this notebook locally, the images will be cached and stored in the directory specified by the <code class="docutils literal notranslate"><span class="pre">root</span></code> parameter of <code class="docutils literal notranslate"><span class="pre">torchvision.datasets.Food101()</span></code>.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span>

<span class="c1"># Setup data directory</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="n">data_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>

<span class="c1"># Get training data (~750 images x 101 food classes)</span>
<span class="n">train_data</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">Food101</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">data_dir</span><span class="p">,</span> <span class="c1"># path to download data to</span>
                              <span class="n">split</span><span class="o">=</span><span class="s2">&quot;train&quot;</span><span class="p">,</span> <span class="c1"># dataset split to get</span>
                              <span class="n">transform</span><span class="o">=</span><span class="n">food101_train_transforms</span><span class="p">,</span> <span class="c1"># perform data augmentation on training data</span>
                              <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># want to download?</span>

<span class="c1"># Get testing data (~250 images x 101 food classes)</span>
<span class="n">test_data</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">Food101</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">data_dir</span><span class="p">,</span>
                             <span class="n">split</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span>
                             <span class="n">transform</span><span class="o">=</span><span class="n">effnetb2_transforms</span><span class="p">,</span> <span class="c1"># perform normal EffNetB2 transforms on test data</span>
                             <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Data downloaded!</p>
<p>Now we can get a list of all the class names using <code class="docutils literal notranslate"><span class="pre">train_data.classes</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get Food101 class names</span>
<span class="n">food101_class_names</span> <span class="o">=</span> <span class="n">train_data</span><span class="o">.</span><span class="n">classes</span>

<span class="c1"># View the first 10</span>
<span class="n">food101_class_names</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;apple_pie&#39;,
 &#39;baby_back_ribs&#39;,
 &#39;baklava&#39;,
 &#39;beef_carpaccio&#39;,
 &#39;beef_tartare&#39;,
 &#39;beet_salad&#39;,
 &#39;beignets&#39;,
 &#39;bibimbap&#39;,
 &#39;bread_pudding&#39;,
 &#39;breakfast_burrito&#39;]
</pre></div>
</div>
</div>
</div>
<p>Ho ho! Those are some delicious sounding foods (although I’ve never heard of “beignets”… update: after a quick Google search, beignets also look delicious).</p>
<p>You can see a full list of the Food101 class names on the course GitHub under <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/extras/food101_class_names.txt"><code class="docutils literal notranslate"><span class="pre">extras/food101_class_names.txt</span></code></a>.</p>
</section>
<section id="creating-a-subset-of-the-food101-dataset-for-faster-experimenting">
<h3>10.3 Creating a subset of the Food101 dataset for faster experimenting<a class="headerlink" href="#creating-a-subset-of-the-food101-dataset-for-faster-experimenting" title="Permalink to this heading">#</a></h3>
<p>This is optional.</p>
<p>We don’t <em>need</em> to create another subset of the Food101 dataset, we could train and evaluate a model across the whole 101,000 images.</p>
<p>But to keep training fast, let’s create a 20% split of the training and test datasets.</p>
<p>Our goal will be to see if we can beat the original <a class="reference external" href="https://data.vision.ee.ethz.ch/cvl/datasets_extra/food-101/">Food101 paper’s</a> best results with only 20% of the data.</p>
<p>To breakdown the datasets we’ve used/will use:</p>
<div class="pst-scrollable-table-container"><table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Notebook(s)</strong></p></th>
<th class="head"><p><strong>Project name</strong></p></th>
<th class="head"><p><strong>Dataset</strong></p></th>
<th class="head"><p><strong>Number of classes</strong></p></th>
<th class="head"><p><strong>Training images</strong></p></th>
<th class="head"><p><strong>Testing images</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>04, 05, 06, 07, 08</p></td>
<td><p>FoodVision Mini (10% data)</p></td>
<td><p>Food101 custom split</p></td>
<td><p>3 (pizza, steak, sushi)</p></td>
<td><p>225</p></td>
<td><p>75</p></td>
</tr>
<tr class="row-odd"><td><p>07, 08, 09</p></td>
<td><p>FoodVision Mini (20% data)</p></td>
<td><p>Food101 custom split</p></td>
<td><p>3 (pizza, steak, sushi)</p></td>
<td><p>450</p></td>
<td><p>150</p></td>
</tr>
<tr class="row-even"><td><p><strong>09 (this one)</strong></p></td>
<td><p>FoodVision Big (20% data)</p></td>
<td><p>Food101 custom split</p></td>
<td><p>101 (all Food101 classes)</p></td>
<td><p>15150</p></td>
<td><p>5050</p></td>
</tr>
<tr class="row-odd"><td><p>Extension</p></td>
<td><p>FoodVision Big</p></td>
<td><p>Food101 all data</p></td>
<td><p>101</p></td>
<td><p>75750</p></td>
<td><p>25250</p></td>
</tr>
</tbody>
</table>
</div>
<p>Can you see the trend?</p>
<p>Just like our model size slowly increased overtime, so has the size of the dataset we’ve been using for experiments.</p>
<blockquote>
<div><p><strong>Note:</strong> To truly beat the original Food101 paper’s results with 20% of the data, we’d have to train a model on 20% of the training data and then evaluate our model on the <em>whole</em> test set rather than the split we created. I’ll leave this as an extension exercise for you to try. I’d also encourage you to try training a model on the entire Food101 training dataset.</p>
</div></blockquote>
<p>To make our FoodVision Big (20% data) split, let’s create a function called <code class="docutils literal notranslate"><span class="pre">split_dataset()</span></code> to split a given dataset into certain proportions.</p>
<p>We can use <a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.random_split"><code class="docutils literal notranslate"><span class="pre">torch.utils.data.random_split()</span></code></a> to create splits of given sizes using the <code class="docutils literal notranslate"><span class="pre">lengths</span></code> parameter.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">lengths</span></code> parameter accepts a list of desired split lengths where the total of the list must equal the overall length of the dataset.</p>
<p>For example, with a dataset of size 100, you could pass in <code class="docutils literal notranslate"><span class="pre">lengths=[20,</span> <span class="pre">80]</span></code> to receive a 20% and 80% split.</p>
<p>We’ll want our function to return two splits, one with the target length (e.g. 20% of the training data) and the other with the remaining length (e.g. the remaining 80% of the training data).</p>
<p>Finally, we’ll set <code class="docutils literal notranslate"><span class="pre">generator</span></code> parameter to a <code class="docutils literal notranslate"><span class="pre">torch.manual_seed()</span></code> value for reproducibility.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span><span class="n">torchvision</span><span class="o">.</span><span class="n">datasets</span><span class="p">,</span> <span class="n">split_size</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Randomly splits a given dataset into two proportions based on split_size and seed.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (torchvision.datasets): A PyTorch Dataset, typically one from torchvision.datasets.</span>
<span class="sd">        split_size (float, optional): How much of the dataset should be split? </span>
<span class="sd">            E.g. split_size=0.2 means there will be a 20% split and an 80% split. Defaults to 0.2.</span>
<span class="sd">        seed (int, optional): Seed for random generator. Defaults to 42.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (random_split_1, random_split_2) where random_split_1 is of size split_size*len(dataset) and </span>
<span class="sd">            random_split_2 is of size (1-split_size)*len(dataset).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create split lengths based on original dataset length</span>
    <span class="n">length_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">*</span> <span class="n">split_size</span><span class="p">)</span> <span class="c1"># desired length</span>
    <span class="n">length_2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">-</span> <span class="n">length_1</span> <span class="c1"># remaining length</span>
        
    <span class="c1"># Print out info</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Splitting dataset of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span><span class="si">}</span><span class="s2"> into splits of size: </span><span class="si">{</span><span class="n">length_1</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">split_size</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="si">}</span><span class="s2">%), </span><span class="si">{</span><span class="n">length_2</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">int</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">split_size</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create splits with given random seed</span>
    <span class="n">random_split_1</span><span class="p">,</span> <span class="n">random_split_2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">random_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> 
                                                                   <span class="n">lengths</span><span class="o">=</span><span class="p">[</span><span class="n">length_1</span><span class="p">,</span> <span class="n">length_2</span><span class="p">],</span>
                                                                   <span class="n">generator</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">))</span> <span class="c1"># set the random seed for reproducible splits</span>
    <span class="k">return</span> <span class="n">random_split_1</span><span class="p">,</span> <span class="n">random_split_2</span>
</pre></div>
</div>
</div>
</div>
<p>Dataset split function created!</p>
<p>Now let’s test it out by creating a 20% training and testing dataset split of Food101.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create training 20% split of Food101</span>
<span class="n">train_data_food101_20_percent</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">train_data</span><span class="p">,</span>
                                                 <span class="n">split_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="c1"># Create testing 20% split of Food101</span>
<span class="n">test_data_food101_20_percent</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">split_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">test_data</span><span class="p">,</span>
                                                <span class="n">split_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="nb">len</span><span class="p">(</span><span class="n">train_data_food101_20_percent</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_data_food101_20_percent</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] Splitting dataset of length 75750 into splits of size: 15150 (20%), 60600 (80%)
[INFO] Splitting dataset of length 25250 into splits of size: 5050 (20%), 20200 (80%)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(15150, 5050)
</pre></div>
</div>
</div>
</div>
<p>Excellent!</p>
</section>
<section id="turning-our-food101-datasets-into-dataloaders">
<h3>10.4 Turning our Food101 datasets into <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>s<a class="headerlink" href="#turning-our-food101-datasets-into-dataloaders" title="Permalink to this heading">#</a></h3>
<p>Now let’s turn our Food101 20% dataset splits into <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>’s using <code class="docutils literal notranslate"><span class="pre">torch.utils.data.DataLoader()</span></code>.</p>
<p>We’ll set <code class="docutils literal notranslate"><span class="pre">shuffle=True</span></code> for the training data only and the batch size to <code class="docutils literal notranslate"><span class="pre">32</span></code> for both datasets.</p>
<p>And we’ll set <code class="docutils literal notranslate"><span class="pre">num_workers</span></code> to <code class="docutils literal notranslate"><span class="pre">4</span></code> if the CPU count is available or <code class="docutils literal notranslate"><span class="pre">2</span></code> if it’s not (though the value of <code class="docutils literal notranslate"><span class="pre">num_workers</span></code> is very experimental and will depend on the hardware you’re using, there’s an <a class="reference external" href="https://discuss.pytorch.org/t/guidelines-for-assigning-num-workers-to-dataloader/813">active discussion thread about this on the PyTorch forums</a>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">NUM_WORKERS</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">4</span> <span class="k">else</span> <span class="mi">4</span> <span class="c1"># this value is very experimental and will depend on the hardware you have available, Google Colab generally provides 2x CPUs</span>

<span class="c1"># Create Food101 20 percent training DataLoader</span>
<span class="n">train_dataloader_food101_20_percent</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">train_data_food101_20_percent</span><span class="p">,</span>
                                                                  <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">,</span>
                                                                  <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                  <span class="n">num_workers</span><span class="o">=</span><span class="n">NUM_WORKERS</span><span class="p">)</span>
<span class="c1"># Create Food101 20 percent testing DataLoader</span>
<span class="n">test_dataloader_food101_20_percent</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">test_data_food101_20_percent</span><span class="p">,</span>
                                                                 <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">,</span>
                                                                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                 <span class="n">num_workers</span><span class="o">=</span><span class="n">NUM_WORKERS</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="training-foodvision-big-model">
<h3>10.5 Training FoodVision Big model<a class="headerlink" href="#training-foodvision-big-model" title="Permalink to this heading">#</a></h3>
<p>FoodVision Big model and <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>s ready!</p>
<p>Time for training.</p>
<p>We’ll create an optimizer using <code class="docutils literal notranslate"><span class="pre">torch.optim.Adam()</span></code> and a learning rate of <code class="docutils literal notranslate"><span class="pre">1e-3</span></code>.</p>
<p>And because we’ve got so many classes, we’ll also setup a loss function using <code class="docutils literal notranslate"><span class="pre">torch.nn.CrossEntropyLoss()</span></code> with <code class="docutils literal notranslate"><span class="pre">label_smoothing=0.1</span></code>, inline with <a class="reference external" href="https://pytorch.org/blog/how-to-train-state-of-the-art-models-using-torchvision-latest-primitives/#label-smoothing"><code class="docutils literal notranslate"><span class="pre">torchvision</span></code>’s state-of-the-art training recipe</a>.</p>
<p>What’s <a class="reference external" href="https://paperswithcode.com/method/label-smoothing"><strong>label smoothing</strong></a>?</p>
<p>Label smoothing is a regularization technique (regularization is another word to describe the process of <a class="reference external" href="https://www.learnpytorch.io/04_pytorch_custom_datasets/#81-how-to-deal-with-overfitting">preventing overfitting</a>) that reduces the value a model gives to anyone label and spreads it across the other labels.</p>
<p>In essence, rather than a model getting <em>too confident</em> on a single label, label smoothing gives a non-zero value to other labels to help aid in generalization.</p>
<p>For example, if a model <em>without</em> label smoothing had the following outputs for 5 classes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>A model <em>with</em> label smoothing may have the following outputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.96</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span>
</pre></div>
</div>
<p>The model is still confident on its prediction of class 3 but giving small values to the other labels forces the model to at least consider other options.</p>
<p>Finally, to keep things quick, we’ll train our model for five epochs using the <code class="docutils literal notranslate"><span class="pre">engine.train()</span></code> function we created in <a class="reference external" href="https://www.learnpytorch.io/05_pytorch_going_modular/#4-creating-train_step-and-test_step-functions-and-train-to-combine-them">05. PyTorch Going Modular section 4</a> with the goal of beating the original Food101 paper’s result of 56.4% accuracy on the test set.</p>
<p>Let’s train our biggest model yet!</p>
<blockquote>
<div><p><strong>Note:</strong> Running the cell below will take ~15-20 minutes to run on Google Colab. This is because it’s training the biggest model with the largest amount of data we’ve used so far (15,150 training images, 5050 testing images). And it’s a reason we decided to split 20% of the full Food101 dataset off before (so training didn’t take over an hour).</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">engine</span>

<span class="c1"># Setup optimizer</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">effnetb2_food101</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span>
                             <span class="n">lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>

<span class="c1"># Setup loss function</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">(</span><span class="n">label_smoothing</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span> <span class="c1"># throw in a little label smoothing because so many classes</span>

<span class="c1"># Want to beat original Food101 paper with 20% of data, need 56.4%+ acc on test dataset</span>
<span class="n">set_seeds</span><span class="p">()</span>    
<span class="n">effnetb2_food101_results</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">effnetb2_food101</span><span class="p">,</span>
                                        <span class="n">train_dataloader</span><span class="o">=</span><span class="n">train_dataloader_food101_20_percent</span><span class="p">,</span>
                                        <span class="n">test_dataloader</span><span class="o">=</span><span class="n">test_dataloader_food101_20_percent</span><span class="p">,</span>
                                        <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
                                        <span class="n">loss_fn</span><span class="o">=</span><span class="n">loss_fn</span><span class="p">,</span>
                                        <span class="n">epochs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "41ba5e6cee154970aa960f83784b421f", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Epoch: 1 | train_loss: 3.6317 | train_acc: 0.2869 | test_loss: 2.7670 | test_acc: 0.4937
Epoch: 2 | train_loss: 2.8615 | train_acc: 0.4388 | test_loss: 2.4653 | test_acc: 0.5387
Epoch: 3 | train_loss: 2.6585 | train_acc: 0.4844 | test_loss: 2.3547 | test_acc: 0.5649
Epoch: 4 | train_loss: 2.5494 | train_acc: 0.5116 | test_loss: 2.3038 | test_acc: 0.5755
Epoch: 5 | train_loss: 2.5006 | train_acc: 0.5239 | test_loss: 2.2805 | test_acc: 0.5810
</pre></div>
</div>
</div>
</div>
<p>Woohoo!!!</p>
<p>Looks like we beat the original Food101 paper’s results of 56.4% accuracy with only 20% of the training data (though we only evaluated on 20% of the testing data too, to fully replicate the results, we could evaluate on 100% of the testing data).</p>
<p>That’s the power of transfer learning!</p>
</section>
<section id="inspecting-loss-curves-of-foodvision-big-model">
<h3>10.6 Inspecting loss curves of FoodVision Big model<a class="headerlink" href="#inspecting-loss-curves-of-foodvision-big-model" title="Permalink to this heading">#</a></h3>
<p>Let’s make our FoodVision Big loss curves visual.</p>
<p>We can do so with the <code class="docutils literal notranslate"><span class="pre">plot_loss_curves()</span></code> function from <code class="docutils literal notranslate"><span class="pre">helper_functions.py</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">helper_functions</span> <span class="kn">import</span> <span class="n">plot_loss_curves</span>

<span class="c1"># Check out the loss curves for FoodVision Big</span>
<span class="n">plot_loss_curves</span><span class="p">(</span><span class="n">effnetb2_food101_results</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/d3eb524e8063a92d79a97df01adecda6a3cf6a9aecb1978c2efb918825c4adcd.png" src="../../_images/d3eb524e8063a92d79a97df01adecda6a3cf6a9aecb1978c2efb918825c4adcd.png" />
</div>
</div>
<p>Nice!!!</p>
<p>It looks like our regularization techniques (data augmentation and label smoothing) helped prevent our model from overfitting (the training loss is still higher than the test loss) this indicates our model has a bit more capacity to learn and could improve with further training.</p>
</section>
<section id="saving-and-loading-foodvision-big">
<h3>10.7 Saving and loading FoodVision Big<a class="headerlink" href="#saving-and-loading-foodvision-big" title="Permalink to this heading">#</a></h3>
<p>Now we’ve trained our biggest model yet, let’s save it so we can load it back in later.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">going_modular.going_modular</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="c1"># Create a model path</span>
<span class="n">effnetb2_food101_model_path</span> <span class="o">=</span> <span class="s2">&quot;09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth&quot;</span> 

<span class="c1"># Save FoodVision Big model</span>
<span class="n">utils</span><span class="o">.</span><span class="n">save_model</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">effnetb2_food101</span><span class="p">,</span>
                 <span class="n">target_dir</span><span class="o">=</span><span class="s2">&quot;models&quot;</span><span class="p">,</span>
                 <span class="n">model_name</span><span class="o">=</span><span class="n">effnetb2_food101_model_path</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] Saving model to: models/09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth
</pre></div>
</div>
</div>
</div>
<p>Model saved!</p>
<p>Before we move on, let’s make sure we can load it back in.</p>
<p>We’ll do so by creating a model instance first with <code class="docutils literal notranslate"><span class="pre">create_effnetb2_model(num_classes=101)</span></code> (101 classes for all Food101 classes).</p>
<p>And then loading the saved <code class="docutils literal notranslate"><span class="pre">state_dict()</span></code> with <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html?highlight=load_state_dict#torch.nn.Module.load_state_dict"><code class="docutils literal notranslate"><span class="pre">torch.nn.Module.load_state_dict()</span></code></a> and <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.load.html"><code class="docutils literal notranslate"><span class="pre">torch.load()</span></code></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create Food101 compatible EffNetB2 instance</span>
<span class="n">loaded_effnetb2_food101</span><span class="p">,</span> <span class="n">effnetb2_transforms</span> <span class="o">=</span> <span class="n">create_effnetb2_model</span><span class="p">(</span><span class="n">num_classes</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>

<span class="c1"># Load the saved model&#39;s state_dict()</span>
<span class="n">loaded_effnetb2_food101</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;models/09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;All keys matched successfully&gt;
</pre></div>
</div>
</div>
</div>
</section>
<section id="checking-foodvision-big-model-size">
<h3>10.8 Checking FoodVision Big model size<a class="headerlink" href="#checking-foodvision-big-model-size" title="Permalink to this heading">#</a></h3>
<p>Our FoodVision Big model is capable of classifying 101 classes versus FoodVision Mini’s 3 classes, a 33.6x increase!</p>
<p>How does this effect the model size?</p>
<p>Let’s find out.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># Get the model size in bytes then convert to megabytes</span>
<span class="n">pretrained_effnetb2_food101_model_size</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;models&quot;</span><span class="p">,</span> <span class="n">effnetb2_food101_model_path</span><span class="p">)</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span> <span class="o">//</span> <span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span> <span class="c1"># division converts bytes to megabytes (roughly) </span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pretrained EffNetB2 feature extractor Food101 model size: </span><span class="si">{</span><span class="n">pretrained_effnetb2_food101_model_size</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Pretrained EffNetB2 feature extractor Food101 model size: 30 MB
</pre></div>
</div>
</div>
</div>
<p>Hmm, it looks like the model size stayed largely the same (30 MB for FoodVision Big and 29 MB for FoodVision Mini) despite the large increase in the number of classes.</p>
<p>This is because all the extra parameters for FoodVision Big are <em>only</em> in the last layer (the classifier head).</p>
<p>All of the base layers are the same between FoodVision Big and FoodVision Mini.</p>
<p>Going back up and comparing the model summaries will give more details.</p>
<div class="pst-scrollable-table-container"><table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Model</strong></p></th>
<th class="head"><p><strong>Output shape (num classes)</strong></p></th>
<th class="head"><p><strong>Trainable parameters</strong></p></th>
<th class="head"><p><strong>Total parameters</strong></p></th>
<th class="head"><p><strong>Model size (MB)</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>FoodVision Mini (EffNetB2 feature extractor)</p></td>
<td><p>3</p></td>
<td><p>4,227</p></td>
<td><p>7,705,221</p></td>
<td><p>29</p></td>
</tr>
<tr class="row-odd"><td><p>FoodVision Big (EffNetB2 feature extractor)</p></td>
<td><p>101</p></td>
<td><p>142,309</p></td>
<td><p>7,843,303</p></td>
<td><p>30</p></td>
</tr>
</tbody>
</table>
</div>
</section>
</section>
<section id="turning-our-foodvision-big-model-into-a-deployable-app">
<h2>11. Turning our FoodVision Big model into a deployable app<a class="headerlink" href="#turning-our-foodvision-big-model-into-a-deployable-app" title="Permalink to this heading">#</a></h2>
<p>We’ve got a trained and saved EffNetB2 model on 20% of the Food101 dataset.</p>
<p>And instead of letting our model live in a folder all its life, let’s deploy it!</p>
<p>We’ll deploy our FoodVision Big model in the same way we deployed our FoodVision Mini model, as a Gradio demo on Hugging Face Spaces.</p>
<p>To begin, let’s create a <code class="docutils literal notranslate"><span class="pre">demos/foodvision_big/</span></code> directory to store our FoodVision Big demo files as well as a <code class="docutils literal notranslate"><span class="pre">demos/foodvision_big/examples</span></code> directory to hold an example image to test the demo with.</p>
<p>When we’re finished we’ll have the following file structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">demos</span><span class="o">/</span>
  <span class="n">foodvision_big</span><span class="o">/</span>
    <span class="mi">09</span><span class="n">_pretrained_effnetb2_feature_extractor_food101_20_percent</span><span class="o">.</span><span class="n">pth</span>
    <span class="n">app</span><span class="o">.</span><span class="n">py</span>
    <span class="n">class_names</span><span class="o">.</span><span class="n">txt</span>
    <span class="n">examples</span><span class="o">/</span>
      <span class="n">example_1</span><span class="o">.</span><span class="n">jpg</span>
    <span class="n">model</span><span class="o">.</span><span class="n">py</span>
    <span class="n">requirements</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth</span></code> is our trained PyTorch model file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">app.py</span></code> contains our FoodVision Big Gradio app.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">class_names.txt</span></code> contains all of the class names for FoodVision Big.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">examples/</span></code> contains example images to use with our Gradio app.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">model.py</span></code> contains the model defintion as well as any transforms assosciated with the model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> contains the dependencies to run our app such as <code class="docutils literal notranslate"><span class="pre">torch</span></code>, <code class="docutils literal notranslate"><span class="pre">torchvision</span></code> and <code class="docutils literal notranslate"><span class="pre">gradio</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># Create FoodVision Big demo path</span>
<span class="n">foodvision_big_demo_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;demos/foodvision_big/&quot;</span><span class="p">)</span>

<span class="c1"># Make FoodVision Big demo directory</span>
<span class="n">foodvision_big_demo_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Make FoodVision Big demo examples directory</span>
<span class="p">(</span><span class="n">foodvision_big_demo_path</span> <span class="o">/</span> <span class="s2">&quot;examples&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="downloading-an-example-image-and-moving-it-to-the-examples-directory">
<h3>11.1 Downloading an example image and moving it to the <code class="docutils literal notranslate"><span class="pre">examples</span></code> directory<a class="headerlink" href="#downloading-an-example-image-and-moving-it-to-the-examples-directory" title="Permalink to this heading">#</a></h3>
<p>For our example image, we’re going to use the faithful <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/images/04-pizza-dad.jpeg"><code class="docutils literal notranslate"><span class="pre">pizza-dad</span></code> image</a> (a photo of my dad eating pizza).</p>
<p>So let’s download it from the course GitHub via the <code class="docutils literal notranslate"><span class="pre">!wget</span></code> command and then we can move it to <code class="docutils literal notranslate"><span class="pre">demos/foodvision_big/examples</span></code> with the <code class="docutils literal notranslate"><span class="pre">!mv</span></code> command (short for “move”).</p>
<p>While we’re here we’ll move our trained Food101 EffNetB2 model from <code class="docutils literal notranslate"><span class="pre">models/09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth</span></code> to <code class="docutils literal notranslate"><span class="pre">demos/foodvision_big</span></code> as well.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Download and move an example image</span>
<span class="o">!</span>wget<span class="w"> </span>https://raw.githubusercontent.com/thangckt/pytorch-deep-learning/main/images/04-pizza-dad.jpeg<span class="w"> </span>
<span class="o">!</span>mv<span class="w"> </span><span class="m">04</span>-pizza-dad.jpeg<span class="w"> </span>demos/foodvision_big/examples/04-pizza-dad.jpg

<span class="c1"># Move trained model to FoodVision Big demo folder (will error if model is already moved)</span>
<span class="o">!</span>mv<span class="w"> </span>models/09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth<span class="w"> </span>demos/foodvision_big
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>--2022-08-25 14:24:41--  https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/04-pizza-dad.jpeg
Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.111.133, 185.199.110.133, 185.199.109.133, ...
Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.111.133|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2874848 (2.7M) [image/jpeg]
Saving to: &#39;04-pizza-dad.jpeg’

04-pizza-dad.jpeg   100%[===================&gt;]   2.74M  7.85MB/s    in 0.3s    

2022-08-25 14:24:43 (7.85 MB/s) - &#39;04-pizza-dad.jpeg’ saved [2874848/2874848]
</pre></div>
</div>
</div>
</div>
</section>
<section id="saving-food101-class-names-to-file-class-names-txt">
<h3>11.2 Saving Food101 class names to file (<code class="docutils literal notranslate"><span class="pre">class_names.txt</span></code>)<a class="headerlink" href="#saving-food101-class-names-to-file-class-names-txt" title="Permalink to this heading">#</a></h3>
<p>Because there are so many classes in the Food101 dataset, instead of storing them as a list in our <code class="docutils literal notranslate"><span class="pre">app.py</span></code> file, let’s saved them to a <code class="docutils literal notranslate"><span class="pre">.txt</span></code> file and read them in when necessary instead.</p>
<p>We’ll just remind ourselves what they look like first by checking out <code class="docutils literal notranslate"><span class="pre">food101_class_names</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check out the first 10 Food101 class names</span>
<span class="n">food101_class_names</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;apple_pie&#39;,
 &#39;baby_back_ribs&#39;,
 &#39;baklava&#39;,
 &#39;beef_carpaccio&#39;,
 &#39;beef_tartare&#39;,
 &#39;beet_salad&#39;,
 &#39;beignets&#39;,
 &#39;bibimbap&#39;,
 &#39;bread_pudding&#39;,
 &#39;breakfast_burrito&#39;]
</pre></div>
</div>
</div>
</div>
<p>Wonderful, now we can write these to a text file by first creating a path to <code class="docutils literal notranslate"><span class="pre">demos/foodvision_big/class_names.txt</span></code> and then opening a file with Python’s <code class="docutils literal notranslate"><span class="pre">open()</span></code> and then writing to it leaving a new line for each class.</p>
<p>Ideally, we want our class names to be saved like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apple_pie</span>
<span class="n">baby_back_ribs</span>
<span class="n">baklava</span>
<span class="n">beef_carpaccio</span>
<span class="n">beef_tartare</span>
<span class="o">...</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create path to Food101 class names</span>
<span class="n">foodvision_big_class_names_path</span> <span class="o">=</span> <span class="n">foodvision_big_demo_path</span> <span class="o">/</span> <span class="s2">&quot;class_names.txt&quot;</span>

<span class="c1"># Write Food101 class names list to file</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">foodvision_big_class_names_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Saving Food101 class names to </span><span class="si">{</span><span class="n">foodvision_big_class_names_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">food101_class_names</span><span class="p">))</span> <span class="c1"># leave a new line between each class</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[INFO] Saving Food101 class names to demos/foodvision_big/class_names.txt
</pre></div>
</div>
</div>
</div>
<p>Excellent, now let’s make sure we can read them in.</p>
<p>To do so we’ll use Python’s <a class="reference external" href="https://www.w3schools.com/python/ref_func_open.asp"><code class="docutils literal notranslate"><span class="pre">open()</span></code></a> in read mode (<code class="docutils literal notranslate"><span class="pre">&quot;r&quot;</span></code>) and then use the <a class="reference external" href="https://www.w3schools.com/python/ref_file_readlines.asp"><code class="docutils literal notranslate"><span class="pre">readlines()</span></code></a> method to read each line of our <code class="docutils literal notranslate"><span class="pre">class_names.txt</span></code> file.</p>
<p>And we can save the class names to a list by stripping the newline value of each of them with a list comprehension and <a class="reference external" href="https://www.w3schools.com/python/ref_string_strip.asp"><code class="docutils literal notranslate"><span class="pre">strip()</span></code></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Open Food101 class names file and read each line into a list</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">foodvision_big_class_names_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">food101_class_names_loaded</span> <span class="o">=</span> <span class="p">[</span><span class="n">food</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">food</span> <span class="ow">in</span>  <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()]</span>
    
<span class="c1"># View the first 5 class names loaded back in</span>
<span class="n">food101_class_names_loaded</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;apple_pie&#39;, &#39;baby_back_ribs&#39;, &#39;baklava&#39;, &#39;beef_carpaccio&#39;, &#39;beef_tartare&#39;]
</pre></div>
</div>
</div>
</div>
</section>
<section id="turning-our-foodvision-big-model-into-a-python-script-model-py">
<h3>11.3 Turning our FoodVision Big model into a Python script (<code class="docutils literal notranslate"><span class="pre">model.py</span></code>)<a class="headerlink" href="#turning-our-foodvision-big-model-into-a-python-script-model-py" title="Permalink to this heading">#</a></h3>
<p>Just like the FoodVision Mini demo, let’s create a script that’s capable of instantiating an EffNetB2 feature extractor model along with its necessary transforms.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%writefile</span> demos/foodvision_big/model.py
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torchvision</span>

<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>


<span class="k">def</span> <span class="nf">create_effnetb2_model</span><span class="p">(</span><span class="n">num_classes</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                          <span class="n">seed</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates an EfficientNetB2 feature extractor model and transforms.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_classes (int, optional): number of classes in the classifier head. </span>
<span class="sd">            Defaults to 3.</span>
<span class="sd">        seed (int, optional): random seed value. Defaults to 42.</span>

<span class="sd">    Returns:</span>
<span class="sd">        model (torch.nn.Module): EffNetB2 feature extractor model. </span>
<span class="sd">        transforms (torchvision.transforms): EffNetB2 image transforms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create EffNetB2 pretrained weights, transforms and model</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">EfficientNet_B2_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
    <span class="n">transforms</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">transforms</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">efficientnet_b2</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Freeze all layers in base model</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
        <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Change classifier head with random seed for reproducibility</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">1408</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="n">num_classes</span><span class="p">),</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">transforms</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Overwriting demos/foodvision_big/model.py
</pre></div>
</div>
</div>
</div>
</section>
<section id="turning-our-foodvision-big-gradio-app-into-a-python-script-app-py">
<h3>11.4 Turning our FoodVision Big Gradio app into a Python script (<code class="docutils literal notranslate"><span class="pre">app.py</span></code>)<a class="headerlink" href="#turning-our-foodvision-big-gradio-app-into-a-python-script-app-py" title="Permalink to this heading">#</a></h3>
<p>We’ve got a FoodVision Big <code class="docutils literal notranslate"><span class="pre">model.py</span></code> script, now let’s create a FoodVision Big <code class="docutils literal notranslate"><span class="pre">app.py</span></code> script.</p>
<p>This will again mostly be the same as the FoodVision Mini <code class="docutils literal notranslate"><span class="pre">app.py</span></code> script except we’ll change:</p>
<ol class="arabic simple">
<li><p><strong>Imports and class names setup</strong> - The <code class="docutils literal notranslate"><span class="pre">class_names</span></code> variable will be a list for all of the Food101 classes rather than pizza, steak, sushi. We can access these via <code class="docutils literal notranslate"><span class="pre">demos/foodvision_big/class_names.txt</span></code>.</p></li>
<li><p><strong>Model and transforms preparation</strong> - The <code class="docutils literal notranslate"><span class="pre">model</span></code> will have <code class="docutils literal notranslate"><span class="pre">num_classes=101</span></code> rather than <code class="docutils literal notranslate"><span class="pre">num_classes=3</span></code>. We’ll also be sure to load the weights from <code class="docutils literal notranslate"><span class="pre">&quot;09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth&quot;</span></code> (our FoodVision Big model path).</p></li>
<li><p><strong>Predict function</strong> - This will stay the same as FoodVision Mini’s <code class="docutils literal notranslate"><span class="pre">app.py</span></code>.</p></li>
<li><p><strong>Gradio app</strong> - The Gradio interace will have different <code class="docutils literal notranslate"><span class="pre">title</span></code>, <code class="docutils literal notranslate"><span class="pre">description</span></code> and <code class="docutils literal notranslate"><span class="pre">article</span></code> parameters to reflect the details of FoodVision Big.</p></li>
</ol>
<p>We’ll also make sure to save it to <code class="docutils literal notranslate"><span class="pre">demos/foodvision_big/app.py</span></code> using the <code class="docutils literal notranslate"><span class="pre">%%writefile</span></code> magic command.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%writefile</span> demos/foodvision_big/app.py
<span class="c1">### 1. Imports and class names setup ### </span>
<span class="kn">import</span> <span class="nn">gradio</span> <span class="k">as</span> <span class="nn">gr</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">model</span> <span class="kn">import</span> <span class="n">create_effnetb2_model</span>
<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span>

<span class="c1"># Setup class names</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;class_names.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="c1"># reading them in from class_names.txt</span>
    <span class="n">class_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">food_name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">food_name</span> <span class="ow">in</span>  <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()]</span>
    
<span class="c1">### 2. Model and transforms preparation ###    </span>

<span class="c1"># Create model</span>
<span class="n">effnetb2</span><span class="p">,</span> <span class="n">effnetb2_transforms</span> <span class="o">=</span> <span class="n">create_effnetb2_model</span><span class="p">(</span>
    <span class="n">num_classes</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="c1"># could also use len(class_names)</span>
<span class="p">)</span>

<span class="c1"># Load saved weights</span>
<span class="n">effnetb2</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
        <span class="n">f</span><span class="o">=</span><span class="s2">&quot;09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth&quot;</span><span class="p">,</span>
        <span class="n">map_location</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">),</span>  <span class="c1"># load to CPU</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="c1">### 3. Predict function ###</span>

<span class="c1"># Create predict function</span>
<span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transforms and performs a prediction on img and returns prediction and time taken.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Start the timer</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    
    <span class="c1"># Transform the target image and add a batch dimension</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">effnetb2_transforms</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Put model into evaluation mode and turn on inference mode</span>
    <span class="n">effnetb2</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">inference_mode</span><span class="p">():</span>
        <span class="c1"># Pass the transformed image through the model and turn the prediction logits into prediction probabilities</span>
        <span class="n">pred_probs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">effnetb2</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Create a prediction label and prediction probability dictionary for each prediction class (this is the required format for Gradio&#39;s output parameter)</span>
    <span class="n">pred_labels_and_probs</span> <span class="o">=</span> <span class="p">{</span><span class="n">class_names</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="nb">float</span><span class="p">(</span><span class="n">pred_probs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">class_names</span><span class="p">))}</span>
    
    <span class="c1"># Calculate the prediction time</span>
    <span class="n">pred_time</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    
    <span class="c1"># Return the prediction dictionary and prediction time </span>
    <span class="k">return</span> <span class="n">pred_labels_and_probs</span><span class="p">,</span> <span class="n">pred_time</span>

<span class="c1">### 4. Gradio app ###</span>

<span class="c1"># Create title, description and article strings</span>
<span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;FoodVision Big 🍔👁&quot;</span>
<span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;An EfficientNetB2 feature extractor computer vision model to classify images of food into [101 different classes](https://github.com/thangckt/pytorch-deep-learning/blob/main/extras/food101_class_names.txt).&quot;</span>
<span class="n">article</span> <span class="o">=</span> <span class="s2">&quot;Created at [09. PyTorch Model Deployment](https://www.learnpytorch.io/09_pytorch_model_deployment/).&quot;</span>

<span class="c1"># Create examples list from &quot;examples/&quot; directory</span>
<span class="n">example_list</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;examples/&quot;</span> <span class="o">+</span> <span class="n">example</span><span class="p">]</span> <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;examples&quot;</span><span class="p">)]</span>

<span class="c1"># Create Gradio interface </span>
<span class="n">demo</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">Interface</span><span class="p">(</span>
    <span class="n">fn</span><span class="o">=</span><span class="n">predict</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="n">gr</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;pil&quot;</span><span class="p">),</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span>
        <span class="n">gr</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="n">num_top_classes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Predictions&quot;</span><span class="p">),</span>
        <span class="n">gr</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Prediction time (s)&quot;</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="n">examples</span><span class="o">=</span><span class="n">example_list</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
    <span class="n">article</span><span class="o">=</span><span class="n">article</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Launch the app!</span>
<span class="n">demo</span><span class="o">.</span><span class="n">launch</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Overwriting demos/foodvision_big/app.py
</pre></div>
</div>
</div>
</div>
</section>
<section id="creating-a-requirements-file-for-foodvision-big-requirements-txt">
<h3>11.5 Creating a requirements file for FoodVision Big (<code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>)<a class="headerlink" href="#creating-a-requirements-file-for-foodvision-big-requirements-txt" title="Permalink to this heading">#</a></h3>
<p>Now all we need is a <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> file to tell our Hugging Face Space what dependencies our FoodVision Big app requires.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%writefile</span> demos/foodvision_big/requirements.txt
<span class="n">torch</span><span class="o">==</span><span class="mf">1.12.0</span>
<span class="n">torchvision</span><span class="o">==</span><span class="mf">0.13.0</span>
<span class="n">gradio</span><span class="o">==</span><span class="mf">3.1.4</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Overwriting demos/foodvision_big/requirements.txt
</pre></div>
</div>
</div>
</div>
</section>
<section id="downloading-our-foodvision-big-app-files">
<h3>11.6 Downloading our FoodVision Big app files<a class="headerlink" href="#downloading-our-foodvision-big-app-files" title="Permalink to this heading">#</a></h3>
<p>We’ve got all the files we need to deploy our FoodVision Big app on Hugging Face, let’s now zip them together and download them.</p>
<p>We’ll use the same process we used for the FoodVision Mini app above in <a class="reference external" href="https://www.learnpytorch.io/09_pytorch_model_deployment/#91-downloading-our-foodvision-mini-app-files">section 9.1: <em>Downloading our Foodvision Mini app files</em></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Zip foodvision_big folder but exclude certain files</span>
<span class="o">!</span><span class="nb">cd</span><span class="w"> </span>demos/foodvision_big<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>zip<span class="w"> </span>-r<span class="w"> </span>../foodvision_big.zip<span class="w"> </span>*<span class="w"> </span>-x<span class="w"> </span><span class="s2">&quot;*.pyc&quot;</span><span class="w"> </span><span class="s2">&quot;*.ipynb&quot;</span><span class="w"> </span><span class="s2">&quot;*__pycache__*&quot;</span><span class="w"> </span><span class="s2">&quot;*ipynb_checkpoints*&quot;</span>

<span class="c1"># Download the zipped FoodVision Big app (if running in Google Colab)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">google.colab</span> <span class="kn">import</span> <span class="n">files</span>
    <span class="n">files</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="s2">&quot;demos/foodvision_big.zip&quot;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not running in Google Colab, can&#39;t use google.colab.files.download()&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>updating: 09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth (deflated 8%)
updating: app.py (deflated 54%)
updating: class_names.txt (deflated 48%)
updating: examples/ (stored 0%)
updating: flagged/ (stored 0%)
updating: model.py (deflated 56%)
updating: requirements.txt (deflated 4%)
updating: examples/04-pizza-dad.jpg (deflated 0%)
Not running in Google Colab, can&#39;t use google.colab.files.download()
</pre></div>
</div>
</div>
</div>
</section>
<section id="deploying-our-foodvision-big-app-to-huggingface-spaces">
<h3>11.7 Deploying our FoodVision Big app to HuggingFace Spaces<a class="headerlink" href="#deploying-our-foodvision-big-app-to-huggingface-spaces" title="Permalink to this heading">#</a></h3>
<p>B, E, A, Utiful!</p>
<p>Time to bring our biggest model of the whole course to life!</p>
<p>Let’s deploy our FoodVision Big Gradio demo to Hugging Face Spaces so we can test it interactively and let others experience the magic of our machine learning efforts!</p>
<blockquote>
<div><p><strong>Note:</strong> There are <a class="reference external" href="https://huggingface.co/docs/hub/repositories-getting-started#getting-started-with-repositories">several ways to upload files to Hugging Face Spaces</a>. The following steps treat Hugging Face as a git repository to track files. However, you can also upload directly to Hugging Face Spaces via the <a class="reference external" href="https://huggingface.co/docs/hub/repositories-getting-started#adding-files-to-a-repository-web-ui">web interface</a> or by the <a class="reference external" href="https://huggingface.co/docs/huggingface_hub/index"><code class="docutils literal notranslate"><span class="pre">huggingface_hub</span></code> library</a>.</p>
</div></blockquote>
<p>The good news is, we’ve already done the steps to do so with FoodVision Mini, so now all we have to do is customize them to suit FoodVision Big:</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://huggingface.co/join">Sign up</a> for a Hugging Face account.</p></li>
<li><p>Start a new Hugging Face Space by going to your profile and then <a class="reference external" href="https://huggingface.co/new-space">clicking “New Space”</a>.</p>
<ul class="simple">
<li><p><strong>Note:</strong> A Space in Hugging Face is also known as a “code repository” (a place to store your code/files) or “repo” for short.</p></li>
</ul>
</li>
<li><p>Give the Space a name, for example, mine is called <code class="docutils literal notranslate"><span class="pre">thangckt/foodvision_big</span></code>, you can see it here: <a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_big">https://huggingface.co/spaces/thangckt/foodvision_big</a></p></li>
<li><p>Select a license (I used <a class="reference external" href="https://opensource.org/licenses/MIT">MIT</a>).</p></li>
<li><p>Select Gradio as the Space SDK (software development kit).</p>
<ul class="simple">
<li><p><strong>Note:</strong> You can use other options such as Streamlit but since our app is built with Gradio, we’ll stick with that.</p></li>
</ul>
</li>
<li><p>Choose whether your Space is it’s public or private (I selected public since I’d like my Space to be available to others).</p></li>
<li><p>Click “Create Space”.</p></li>
<li><p>Clone the repo locally by running: <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span> <span class="pre">https://huggingface.co/spaces/[YOUR_USERNAME]/[YOUR_SPACE_NAME]</span></code> in terminal or command prompt.</p>
<ul class="simple">
<li><p><strong>Note:</strong> You can also add files via uploading them under the “Files and versions” tab.</p></li>
</ul>
</li>
<li><p>Copy/move the contents of the downloaded <code class="docutils literal notranslate"><span class="pre">foodvision_big</span></code> folder to the cloned repo folder.</p></li>
<li><p>To upload and track larger files (e.g. files over 10MB or in our case, our PyTorch model file) you’ll need to <a class="reference external" href="https://git-lfs.github.com/">install Git LFS</a> (which stands for “git large file storage”).</p></li>
<li><p>After you’ve installed Git LFS, you can activate it by running <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">lfs</span> <span class="pre">install</span></code>.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">foodvision_big</span></code> directory, track the files over 10MB with Git LFS with <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">lfs</span> <span class="pre">track</span> <span class="pre">&quot;*.file_extension&quot;</span></code>.</p>
<ul class="simple">
<li><p>Track EffNetB2 PyTorch model file with <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">lfs</span> <span class="pre">track</span> <span class="pre">&quot;09_pretrained_effnetb2_feature_extractor_food101_20_percent.pth&quot;</span></code>.</p></li>
<li><p><strong>Note:</strong> If you get any errors uploading images, you may have to track them with <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">lfs</span></code> too, for example <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">lfs</span> <span class="pre">track</span> <span class="pre">&quot;examples/04-pizza-dad.jpg&quot;</span></code></p></li>
</ul>
</li>
<li><p>Track <code class="docutils literal notranslate"><span class="pre">.gitattributes</span></code> (automatically created when cloning from HuggingFace, this file will help ensure our larger files are tracked with Git LFS). You can see an example <code class="docutils literal notranslate"><span class="pre">.gitattributes</span></code> file on the <a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_big/blob/main/.gitattributes">FoodVision Big Hugging Face Space</a>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">add</span> <span class="pre">.gitattributes</span></code></p></li>
</ul>
</li>
<li><p>Add the rest of the <code class="docutils literal notranslate"><span class="pre">foodvision_big</span></code> app files and commit them with:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">add</span> <span class="pre">*</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">commit</span> <span class="pre">-m</span> <span class="pre">&quot;first</span> <span class="pre">commit&quot;</span></code></p></li>
</ul>
</li>
<li><p>Push (upload) the files to Hugging Face:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">push</span></code></p></li>
</ul>
</li>
<li><p>Wait 3-5 minutes for the build to happen (future builds are faster) and your app to become live!</p></li>
</ol>
<p>If everything worked correctly, our FoodVision Big Gradio demo should be ready to classify!</p>
<p>You can see my version here: <a class="reference external" href="https://huggingface.co/spaces/thangckt/foodvision_big/">https://huggingface.co/spaces/thangckt/foodvision_big/</a></p>
<p>Or we can even embed our FoodVision Big Gradio demo right within our notebook as an <a class="reference external" href="https://gradio.app/sharing_your_app/#embedding-with-iframes">iframe</a> with <a class="reference external" href="https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html#IPython.display.IFrame"><code class="docutils literal notranslate"><span class="pre">IPython.display.IFrame</span></code></a> and a link to our space in the format <code class="docutils literal notranslate"><span class="pre">https://hf.space/embed/[YOUR_USERNAME]/[YOUR_SPACE_NAME]/+</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># IPython is a library to help work with Python iteractively </span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">IFrame</span>

<span class="c1"># Embed FoodVision Big Gradio demo as an iFrame</span>
<span class="n">IFrame</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="s2">&quot;https://hf.space/embed/thangckt/foodvision_big/+&quot;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s2">&quot;width:900px&quot;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">750</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
        <iframe
            width="900"
            height="750"
            src="https://hf.space/embed/mrdbourke/foodvision_big/+"
            frameborder="0"
            allowfullscreen
            
        ></iframe>
        </div></div>
</div>
<p>How cool is that!?!</p>
<p>We’ve come a long way from building PyTorch models to predict a straight line… now we’re building computer vision models accessible to people all around the world!</p>
</section>
</section>
<section id="main-takeaways">
<h2>Main takeaways<a class="headerlink" href="#main-takeaways" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p><strong>Deployment is as important as training.</strong> Once you’ve got a good working model, your first question should be: how can I deploy this and make it accessible to others? Deployment allows you to test your model in the real world rather than on private training and test sets.</p></li>
<li><p><strong>Three questions for machine learning model deployment:</strong></p>
<ol class="arabic simple">
<li><p>What’s the most ideal use case for the model (how well and how fast does it perform)?</p></li>
<li><p>Where’s the model going to go (is it on-device or on the cloud)?</p></li>
<li><p>How’s the model going to function (are predictions online or offline)?</p></li>
</ol>
</li>
<li><p><strong>Deployment options are a plenty.</strong> But best to start simple. One of the best current ways (I say current because these things are always changing) is to use Gradio to create a demo and host it on Hugging Face Spaces. Start simple and scale up when needed.</p></li>
<li><p><strong>Never stop experimenting.</strong> Your machine learning model needs will likely change overtime so deploying a single model is not the last step. You might find the dataset changes, so you’ll have to update your model. Or new research gets released and there’s a better architecture to use.</p>
<ul>
<li><p>So deploying one model is an excellent step, but you’ll likely want to update it over time.</p></li>
</ul>
</li>
<li><p><strong>Machine learning model deployment is part of the engineering practice of MLOps (machine learning operations).</strong> MLOps is an extension of DevOps (development operations) and involves all the engineering parts around training a model: data collection and storage, data preprocessing, model deployment, model monitoring, versioning and more. It’s a rapidly evolving field but there are some solid resources out there to learn more, many of which are in <a class="reference external" href="https://www.learnpytorch.io/pytorch_extra_resources/#resources-for-machine-learning-and-deep-learning-engineering">PyTorch Extra Resources</a>.</p></li>
</ul>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<p>All of the exercises are focused on practicing the code above.</p>
<p>You should be able to complete them by referencing each section or by following the resource(s) linked.</p>
<p><strong>Resources:</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/extras/exercises/09_pytorch_model_deployment_exercises.ipynb">Exercise template notebook for 09</a>.</p></li>
<li><p><a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/blob/main/extras/solutions/09_pytorch_model_deployment_exercise_solutions.ipynb">Example solutions notebook for 09</a> try the exercises <em>before</em> looking at this.</p>
<ul>
<li><p>See a live <a class="reference external" href="https://youtu.be/jOX5ZCkWO-0">video walkthrough of the solutions on YouTube</a> (errors and all).</p></li>
</ul>
</li>
</ul>
<ol class="arabic simple">
<li><p>Make and time predictions with both feature extractor models on the test dataset using the GPU (<code class="docutils literal notranslate"><span class="pre">device=&quot;cuda&quot;</span></code>). Compare the model’s prediction times on GPU vs CPU - does this close the gap between them? As in, does making predictions on the GPU make the ViT feature extractor prediction times closer to the EffNetB2 feature extractor prediction times?</p>
<ul class="simple">
<li><p>You’ll find code to do these steps in <a class="reference external" href="https://www.learnpytorch.io/09_pytorch_model_deployment/#5-making-predictions-with-our-trained-models-and-timing-them">section 5. Making predictions with our trained models and timing them</a> and <a class="reference external" href="https://www.learnpytorch.io/09_pytorch_model_deployment/#6-comparing-model-results-prediction-times-and-size">section 6. Comparing model results, prediction times and size</a>.</p></li>
</ul>
</li>
<li><p>The ViT feature extractor seems to have more learning capacity (due to more parameters) than EffNetB2, how does it go on the larger 20% split of the entire Food101 dataset?</p>
<ul class="simple">
<li><p>Train a ViT feature extractor on the 20% Food101 dataset for 5 epochs, just like we did with EffNetB2 in section <a class="reference external" href="https://www.learnpytorch.io/09_pytorch_model_deployment/#10-creating-foodvision-big">10. Creating FoodVision Big</a>.</p></li>
</ul>
</li>
<li><p>Make predictions across the 20% Food101 test dataset with the ViT feature extractor from exercise 2 and find the “most wrong” predictions.</p>
<ul class="simple">
<li><p>The predictions will be the ones with the highest prediction probability but with the wrong predicted label.</p></li>
<li><p>Write a sentence or two about why you think the model got these predictions wrong.</p></li>
</ul>
</li>
<li><p>Evaluate the ViT feature extractor across the whole Food101 test dataset rather than just the 20% version, how does it perform?</p>
<ul class="simple">
<li><p>Does it beat the original Food101 paper’s best result of 56.4% accuracy?</p></li>
</ul>
</li>
<li><p>Head to <a class="reference external" href="https://paperswithcode.com/">Paperswithcode.com</a> and find the current best performing model on the Food101 dataset.</p>
<ul class="simple">
<li><p>What model architecture does it use?</p></li>
</ul>
</li>
<li><p>Write down 1-3 potential failure points of our deployed FoodVision models and what some potential solutions might be.</p>
<ul class="simple">
<li><p>For example, what happens if someone was to upload a photo that wasn’t of food to our FoodVision Mini model?</p></li>
</ul>
</li>
<li><p>Pick any dataset from <a class="reference external" href="https://pytorch.org/vision/stable/datasets.html"><code class="docutils literal notranslate"><span class="pre">torchvision.datasets</span></code></a> and train a feature extractor model on it using a model from <a class="reference external" href="https://pytorch.org/vision/stable/models.html"><code class="docutils literal notranslate"><span class="pre">torchvision.models</span></code></a> (you could use one of the model’s we’ve already created, e.g. EffNetB2 or ViT) for 5 epochs and then deploy your model as a Gradio app to Hugging Face Spaces.</p>
<ul class="simple">
<li><p>You may want to pick smaller dataset/make a smaller split of it so training doesn’t take too long.</p></li>
<li><p>I’d love to see your deployed models! So be sure to share them in Discord or on the <a class="reference external" href="https://github.com/thangckt/pytorch-deep-learning/discussions">course GitHub Discussions page</a>.</p></li>
</ul>
</li>
</ol>
</section>
<section id="extra-curriculum">
<h2>Extra-curriculum<a class="headerlink" href="#extra-curriculum" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Machine learning model deployment is generally an engineering challenge rather than a pure machine learning challenge, see the <a class="reference external" href="https://www.learnpytorch.io/pytorch_extra_resources/#resources-for-machine-learning-and-deep-learning-engineering">PyTorch Extra Resources machine learning engineering section</a> for resources on learning more.</p>
<ul>
<li><p>Inside you’ll find recommendations for resources such as Chip Huyen’s book <a class="reference external" href="https://www.amazon.com/Designing-Machine-Learning-Systems-Production-Ready/dp/1098107969"><em>Designing Machine Learning Systems</em></a> (especially chapter 7 on model deployment) and Goku Mohandas’s <a class="reference external" href="https://madewithml.com/#mlops">Made with ML MLOps course</a>.</p></li>
</ul>
</li>
<li><p>As you start to build more and more of your own projects, you’ll likely start using Git (and potentially GitHub) quite frequently. To learn more about both, I’d recommend the <a class="reference external" href="https://youtu.be/RGOj5yH7evk"><em>Git and GitHub for Beginners - Crash Course</em></a> video on the freeCodeCamp YouTube channel.</p></li>
<li><p>We’ve only scratched the surface with what’s possible with Gradio. For more, I’d recommend checking out the <a class="reference external" href="https://gradio.app/docs/">full documentation</a>, especially:</p>
<ul>
<li><p>All of the different kinds of <a class="reference external" href="https://gradio.app/docs/#components">input and output components</a>.</p></li>
<li><p>The <a class="reference external" href="https://gradio.app/docs/#blocks">Gradio Blocks API</a> for more advanced workflows.</p></li>
<li><p>The Hugging Face Course chapter on <a class="reference external" href="https://huggingface.co/course/chapter9/1">how to use Gradio with Hugging Face</a>.</p></li>
</ul>
</li>
<li><p>Edge devices aren’t limited to mobile phones, they include small computers like the Raspberry Pi and the PyTorch team have a <a class="reference external" href="https://pytorch.org/tutorials/intermediate/realtime_rpi.html">fantastic blog post tutorial</a> on deploying a PyTorch model to one.</p></li>
<li><p>For a fanstastic guide on developing AI and ML-powered applications, see <a class="reference external" href="https://pair.withgoogle.com/guidebook">Google’s People + AI Guidebook</a>. One of my favourites is the section on <a class="reference external" href="https://pair.withgoogle.com/guidebook/patterns#set-the-right-expectations">setting the right expectations</a>.</p>
<ul>
<li><p>I covered more of these kinds of resources, including guides from Apple, Microsoft and more in the <a class="reference external" href="https://zerotomastery.io/blog/machine-learning-monthly-april-2021/">April 2021 edition of Machine Learning Monthly</a> (a monthly newsletter I send out with the latest and greatest of the ML field).</p></li>
</ul>
</li>
<li><p>If you’d like to speed up your model’s runtime on CPU, you should be aware of <a class="reference external" href="https://pytorch.org/tutorials/beginner/Intro_to_TorchScript_tutorial.html">TorchScript</a>, <a class="reference external" href="https://pytorch.org/docs/stable/onnx.html">ONNX</a> (Open Neural Network Exchange) and <a class="reference external" href="https://docs.openvino.ai/latest/notebooks/102-pytorch-onnx-to-openvino-with-output.html">OpenVINO</a>. Going from pure PyTorch to ONNX/OpenVINO models I’ve seen a ~2x+ increase in performance.</p></li>
<li><p>For turning models into a deployable and scalable API, see the <a class="reference external" href="https://pytorch.org/serve/">TorchServe library</a>.</p></li>
<li><p>For a terrific example and rationale as to why deploying a machine learning model in the browser (a form of edge deployment) offers several benefits (no network transfer latency delay), see Jo Kristian Bergum’s article on <a class="reference external" href="https://bergum.medium.com/moving-ml-inference-from-the-cloud-to-the-edge-d6f98dbdb2e3"><em>Moving ML Inference from the Cloud to the Edge</em></a>.</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebook/pytorch_deep_learning"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="08_pytorch_paper_replicating.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">08. PyTorch Paper Replicating</p>
      </div>
    </a>
    <a class="right-next"
       href="extras/pytorch_extra_resources.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">PyTorch Extra Resources</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-machine-learning-model-deployment">What is machine learning model deployment?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-deploy-a-machine-learning-model">Why deploy a machine learning model?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#different-types-of-machine-learning-model-deployment">Different types of machine learning model deployment</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wheres-it-going-to-go">Where’s it going to go?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hows-it-going-to-function">How’s it going to function?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ways-to-deploy-a-machine-learning-model">Ways to deploy a machine learning model</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#what-were-going-to-cover">What we’re going to cover</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#where-can-you-get-help">Where can you get help?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-setup">0. Getting setup</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-data">1. Getting data</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#foodvision-mini-model-deployment-experiment-outline">2. FoodVision Mini model deployment experiment outline</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-an-effnetb2-feature-extractor">3. Creating an EffNetB2 feature extractor</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-function-to-make-an-effnetb2-feature-extractor">3.1 Creating a function to make an EffNetB2 feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-dataloaders-for-effnetb2">3.2 Creating DataLoaders for EffNetB2</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#training-effnetb2-feature-extractor">3.3 Training EffNetB2 feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inspecting-effnetb2-loss-curves">3.4 Inspecting EffNetB2 loss curves</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-effnetb2-feature-extractor">3.5 Saving EffNetB2 feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#checking-the-size-of-effnetb2-feature-extractor">3.6 Checking the size of EffNetB2 feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#collecting-effnetb2-feature-extractor-stats">3.7 Collecting EffNetB2 feature extractor stats</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-vit-feature-extractor">4. Creating a ViT feature extractor</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#create-dataloaders-for-vit">4.1 Create DataLoaders for ViT</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#training-vit-feature-extractor">4.2 Training ViT feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inspecting-vit-loss-curves">4.3 Inspecting ViT loss curves</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-vit-feature-extractor">4.4 Saving ViT feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#checking-the-size-of-vit-feature-extractor">4.5 Checking the size of ViT feature extractor</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#collecting-vit-feature-extractor-stats">4.6 Collecting ViT feature extractor stats</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#making-predictions-with-our-trained-models-and-timing-them">5. Making predictions with our trained models and timing them</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-function-to-make-predictions-across-the-test-dataset">5.1 Creating a function to make predictions across the test dataset</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-and-timing-predictions-with-effnetb2">5.2 Making and timing predictions with EffNetB2</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-and-timing-predictions-with-vit">5.3 Making and timing predictions with ViT</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#comparing-model-results-prediction-times-and-size">6. Comparing model results, prediction times and size</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualizing-the-speed-vs-performance-tradeoff">6.1 Visualizing the speed vs. performance tradeoff</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bringing-foodvision-mini-to-life-by-creating-a-gradio-demo">7. Bringing FoodVision Mini to life by creating a Gradio demo</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gradio-overview">7.1 Gradio overview</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-function-to-map-our-inputs-and-outputs">7.2 Creating a function to map our inputs and outputs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-list-of-example-images">7.3 Creating a list of example images</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#building-a-gradio-interface">7.4 Building a Gradio interface</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-mini-gradio-demo-into-a-deployable-app">8. Turning our FoodVision Mini Gradio Demo into a deployable app</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-hugging-face-spaces">8.1 What is Hugging Face Spaces?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deployed-gradio-app-structure">8.2 Deployed Gradio app structure</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-demos-folder-to-store-our-foodvision-mini-app-files">8.3 Creating a <code class="docutils literal notranslate"><span class="pre">demos</span></code> folder to store our FoodVision Mini app files</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-folder-of-example-images-to-use-with-our-foodvision-mini-demo">8.4 Creating a folder of example images to use with our FoodVision Mini demo</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#moving-our-trained-effnetb2-model-to-our-foodvision-mini-demo-directory">8.5 Moving our trained EffNetB2 model to our FoodVision Mini demo directory</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-effnetb2-model-into-a-python-script-model-py">8.6 Turning our EffNetB2 model into a Python script (<code class="docutils literal notranslate"><span class="pre">model.py</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-mini-gradio-app-into-a-python-script-app-py">8.7 Turning our FoodVision Mini Gradio app into a Python script (<code class="docutils literal notranslate"><span class="pre">app.py</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-requirements-file-for-foodvision-mini-requirements-txt">8.8 Creating a requirements file for FoodVision Mini (<code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deploying-our-foodvision-mini-app-to-huggingface-spaces">9. Deploying our FoodVision Mini app to HuggingFace Spaces</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downloading-our-foodvision-mini-app-files">9.1 Downloading our FoodVision Mini app files</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#running-our-foodvision-mini-demo-locally">9.2 Running our FoodVision Mini demo locally</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#uploading-to-hugging-face">9.3 Uploading to Hugging Face</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-foodvision-big">10. Creating FoodVision Big</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-model-and-transforms-for-foodvision-big">10.1 Creating a model and transforms for FoodVision Big</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-data-for-foodvision-big">10.2 Getting data for FoodVision Big</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-subset-of-the-food101-dataset-for-faster-experimenting">10.3 Creating a subset of the Food101 dataset for faster experimenting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-food101-datasets-into-dataloaders">10.4 Turning our Food101 datasets into <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>s</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#training-foodvision-big-model">10.5 Training FoodVision Big model</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inspecting-loss-curves-of-foodvision-big-model">10.6 Inspecting loss curves of FoodVision Big model</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-and-loading-foodvision-big">10.7 Saving and loading FoodVision Big</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#checking-foodvision-big-model-size">10.8 Checking FoodVision Big model size</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-big-model-into-a-deployable-app">11. Turning our FoodVision Big model into a deployable app</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downloading-an-example-image-and-moving-it-to-the-examples-directory">11.1 Downloading an example image and moving it to the <code class="docutils literal notranslate"><span class="pre">examples</span></code> directory</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-food101-class-names-to-file-class-names-txt">11.2 Saving Food101 class names to file (<code class="docutils literal notranslate"><span class="pre">class_names.txt</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-big-model-into-a-python-script-model-py">11.3 Turning our FoodVision Big model into a Python script (<code class="docutils literal notranslate"><span class="pre">model.py</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#turning-our-foodvision-big-gradio-app-into-a-python-script-app-py">11.4 Turning our FoodVision Big Gradio app into a Python script (<code class="docutils literal notranslate"><span class="pre">app.py</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-requirements-file-for-foodvision-big-requirements-txt">11.5 Creating a requirements file for FoodVision Big (<code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#downloading-our-foodvision-big-app-files">11.6 Downloading our FoodVision Big app files</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deploying-our-foodvision-big-app-to-huggingface-spaces">11.7 Deploying our FoodVision Big app to HuggingFace Spaces</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#main-takeaways">Main takeaways</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#extra-curriculum">Extra-curriculum</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By thangckt
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>